## 코틀린 자료구조 복습
- 이라고 하기엔 첨본 내용도 많음

### 리스트
- 같은 타입을 갖는 원소의 순서 있는 집합을 이야기함
- 코틀린에서는 list 함수를 사용해서 리스트를 선언함
```
val hobbits = listOf(“프로도”, “샘”, “피핀”, “메리”)
```
- 리스트의 타입을 선언하지 않았다는 점에 주목
- 코틀린에서는 변수를 초기화할 때와 마찬가지로 집합 자료 구조를 만들 때도 타입 추론이 가능하기 때문
- 리스트의 다입을 명시하고 싶다면 함수의 인수 정의와 비슷한 방법으로 사용할 수 있음
```
val hobbits: List<String> = listOf(“프로도”, “샘” , “피핀” , “메리”)
```
- 특정 인덱스로 리스트 원소에 접근할 때는 대괄호를 사용
```
println(hobbits[1])
//코드 실행 시 아래와 같이 출력됨
>샘
```

### 세트
- 세트는 중복없는 원소의 집합
- 세트에서 원솔르 찾는 것은 리스트에서보더 훨씬 빠름
- 리스트와 달리 인덱스에서의 접근은 불가능하다
- 대충 똑같은거 때려박아도 중복이 안되게 출력됨

```
val footballChampions = setOf(“프랑스”, “독일”,“스페인”,“이탈리아”,“브라질”,“프랑스”,“브라질”,“독일”)
println(footballChampions) //[프랑스, 독일, 스페인, 이탈리아. 브라질]
```
- 세트에 어떤 원소가 있는지는 in 함수를 사용함
```
println(입력값 in setOf 변수)
```
- 일반적으로 세트는 원소의 순서를 보장하지 않음
- 그러나 현재 setOf() 함수는 LinkedHashSet을 반환하도록 구현되어있는데, 이 클래스는 원소가 추가된 순서를 보존한다.
- 즉 위의 예제에서 프랑스는 맨 먼저 출력되는데, 이는 입력 순서상 가장 앞에 있었던 까닭임

### 맵
- 맵은 키의 유일성이 보장되는 키-값 쌍의 집합
- 두 원소의 쌍을 만드는 키워드는 to
- 사실 to는 진짜 키워드는 아니고 특별한 함수임
```
val movieBatmans = mapOf(
	“배트맨 리턴즈” to “마이클 키튼”,
	“배트맨 포에버” to “발 킬머”
	“배트맨과 로빈” to “조지 클루니”
)
println(movieBatmans)
```
- 키를 이용해 값을 조회하려면. 대괄호 안에 키를 넣으면 됨
```
println(movieBatmans[“배트맨 리턴즈”])
```
- 부재를 검사하는 기능도 있음
```
println(“배트맨 비긴즈” !in movieBatman)
> true //이런식으로 출력
```

### 가변성
- 여태 소개한 자료구조는 불변임 더 정확히는 읽기 전용임
- listOf() 함수로 만든 리스트에는 새로운 원소를 추가하는 메서드가 없음.
- 원소의 값을 바꿀 수도 없음
- 불변 자료구조는 동시성 코드를 작성할떄 매우 도움이 됨
- 하지만 수정 가능한 자료구조가 필요할 때도 있는데 그러럐ㄸ는 집합 자료 구조를 만드는 함수의 가변 버전을 사용할 수 있음
```
val editableHobbits = mutableListOf("프로도", "샘", "피핀", "메리")
editableHobbits.add("빌보")
```
- 수정 가능한 집합에는 add()같은 함수가 있어서 변경이 가능함. 즉 가변적이다.

### 집합 자료 구조의 다른 구현체
- 이전에 JVM을 사용해 본적이 있다면 세트와 맵에 다른 구현체가 있다는 것을 알 것
- 예를들어 TreeMap은 키를 정렬된 상태로 저장함
```
import java.util.*
//키로 정렬되는 가변 맵

val treeMap = java.util.TreeMap(
    mapOf("첫째돼지" to "지푸라기 집",
        "둘째 돼지" to "나무 집",
        "셋쨰 돼지" to "벽돌 집"
    )
)
println(treeMap.keys)
```
- 다음과 같이 출력될 것
```
> 둘째 돼지, 셋째 돼지, 첫째 돼지
```
- 알고리즘에 써먹어라
- 가나다 순으로 알아서 정렬됨

### 배열
- 이 절에서 꼭 짚고 넘어가야 할 자료구조래
- 자바에서 배열은 대괄호를 사용하는 특별한 문법을 갖고있음
- 코틀린에서는 대괄호 뭐시깽이 말고 컬렉션을 사용함(제네릭 함수)
#### 아래와 같이 선언함
```
val musketeers: Array<String> = arrayOf("아토스", "포르토스", "아라미스")
```
- 코틀린 코드에 처음으로 꺾쇠 괄호가 등장함 
- 자바나 타입스크립트에서 처럼 꺾쇠 괄호가 들어가는 타입을 타입인수라고 함
- 여기선 배열에 문자열이 들어있다는 것을 나타냄
- 4장 제네릭 설명때 다시 이야기함
#### 이미 만들어진 집합 자료 구조를 배열로 변환하고자 한다면 toTypedArray함수를 이용한다.
```
listOf(1,2,3,5).toTypedArray()
``` 
- 기능적인 측면에서 코틀린 배열은 리스트와 매우 유사함
- 예를 들어 코틀린 배열의 원소 갯수를 구하려면 다른 집ㅎ바 구조와 마찬가지로 size속성을 사용
- 언제 배열을 사용해야하나 먼저 main 함수에서 인수를 받을 때
- 앞에 예제에서는 인수 없는 main함수만 봤지만 명령줄 인수를 전달하는 경우도 있음
#### 다음 예제는 명령줄 인수를 받아서 쉼표로 연결한 뒤 출력하는 main함수임
```
fun main(args: Array<String>){
    println(args.joinToString(", "))
}
```
- 배열을 인수로 받는 자바 함수를 호출하거나 varargs 문법을 사용하는 경웽도 배열이 필요함
- 이런 내용은 3장에서 다룸
