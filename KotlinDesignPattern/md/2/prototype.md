## 프로토 타임 패턴
- 프로토타입 디자인 패턴은 유사하면서도 조금 다른 객체를 그때그때 목적에 맞게 생성하기 위해 사용됨
- 이게 뭔뜻이냐?
- 사용자와 권한을 관리하는 시스템을 만든다고 상상해보자.
- 사용자를 나타내는 데이터 클래스는 다음과 같다
```
data class User(
  val name: String,
  val role: Role,
  val permissions: Set<String>,
) {
  fun hasPermission(permission: String) = permission in permissions
}
```
- 각 사용자는 하나의 역할을 가져야 하며 각 역할은 여러 권한을 갖는다
- 역할은 다음과 같이 enum 클래스로 정의할 수 있음
```
enum class Role {
  ADMIN,
  SUPER_ADMIN,
  REGULAR_USER
}
```
- enum 클래스는 상수의 모음을 표현하기 위해 사용됨
- 역할은 문자열 등 다른 타입으로도 표현할 수 있지만 enum 클래스를 사용하는 쪽이 편하다.
- 해당 객체가 존재하는지 컴파일 타임에 검사해주기 때문
- 새로운 사용자를 만들 땐 동일한 역할을 갖는 다른 사용자와 비슷한 권한을 부여함
```
// 실제 어플리케이션에서는 사용자 데이터베이스에 해당
val allUsers = mutableListOf<User>()

fun createUser(name: String, role : Role){
  for(u in allUsers){
    if(u.role == role) {
      allUser += User(name, role, u.permissions)
      return
    }
  }
  // 같은 권한을 갖는 다른 사용자가 존재하지 않는 경우 처리
}
```
- User 클래스에 tasks라는 새로운 필드를 추가해야 한다고 하자
```
data class User (
  val name: String,
  val role: Role,
  val permissions: Set<String>,
  val tasks: List<String>
)
```
- 이제 createUser함수는 더 이상 컴파일 되지 않는다.
- 신규 필드의 값을 새 인스턴스에 복사하도록 코드를 수정해야함
```
allUsers += User(name, role, u.permissions, u.tasks)
```
- User 클래스가 바뀔 때 마다 이런식으로 코드를 수정해줘야 할 것임
- 더 큰 문제가 있는데, 가령 요구사항이 추가돼서 permissions 속성을 비공개로 바꿔야 한다면 어떻게 되나?
```
data class User(
  val name: String,
  val role: Role,
  private val permissions: Set<String>,
  val tasks: List<String>,
){
  ...
}
```
- 컴파일 오류가 발생할 것이고, 또다시 코드를 수정해야 함
- 이렇게 거듭 코드를 변경해야 한다는 것은 다른 접근 방법이 필요하다는 뚜렷한 신호임

### 프로토타입에서 시작하기
- 프로토타입의 핵심 아이디어는 객체를 쉽게 복사할 수 있도록 하는 것.
- 적어도 다음의 두가지 경우에 프로토 타입 패턴이 필요하다.
  - 객체 생성에 많은 비용이 드는 경우(예를 들어 객체 생성 시 데이터베이스에서 자료를 조회해야 하는 경우)
  - 비슷하지만 조금씩 다른 객체를 생성하느라 비슷한 코드를 매번 반복하고 싶지 않은 경우
> 더 깊이 들어가면 프로토타입 패턴이 필요한 다른 이유도 있음
> 가령 자바스크립트에서는 클래스 없이 객체와 비슷한 동작을 구현하기 위해 프로토타입을 사용
- 자바의 엉터리같은 clone() 메서드가 다행히도 코틀린에서는 고쳐짐
- 코틀린에서 모든 데이터클래스는 copy()메서드를 가짐
- 이 메서드는 다른 데이터 클래스의 인스턴스를 받아 복제본을 생성하며, 원한다면 그 과정에서 속성을 변경할 수도 있다.

```
//인수 이름이 밑줄 문자(_)로 시작하는 것은 User 객체에서
// 같은 이름을 갖는 속성과 혼동하지 않게 하려는 것
fun createUser(_name: String, role: Role){
  for(u in allUsers){
    if(u.role == role) {
      allUsers += u.copy(name = _name)
      return
    }
  }
  // 같은 권한을 갖는 다른 사용자가 존재하지 않는 경우 처리
}
```
- 빌더 패턴에서 봤던 것과 비슷하게 명명 인수를 사용해서 순서에 관계없이 속성을 설정할 수 있다.
- 또한 변경하고 싶은 속성만 지정해 주면 됨
- 다른 데이터는(비공개 속성까지도) 모두 그대로 복사된다.
- 데이터 클래스는 디자인 패턴이 너무 흔하게 사용되는 나머지 아예 언어 문법의 일부가 돼 버린 예
- 데이터 클래스는 굉장히 유용한 기능이기 때문에 책 전반에서 반복적으로 사용될 것

## 요약
- 2장에서는 생성 디자인 패턴을 언제 그리고 어떻게 사용하는지 배웠다
- 먼저 싱글톤 클래스를 만들기 위해 object 키워드를 사용하는 법과 정적 팩토리 메서드를 만드는 데에 필요한 companion object를 살펴봤다.
- 또한 여러 변수를 한 번에 할당하는 분해 선언도 다뤗음
- 다음으로는 스마트 캐스팅을 배우며 추상 팩토리 디자인 패턴에서 연관된 객체를 한 가족으로 묶을 때 스마트 캐스팅을 사용하는 법을 살펴보았음
- 뒤이어 빌더 디자인 패턴을 봤고 매개변수가 기본값을 갖는 함수를 배움
- 또한 위치가 아닌 이름을 통해 인수를 전달하는 방법도 배웠음
- 마지막으로 데이터 클래스의 copy() 함수를 다루며, 비슷하지만 조금씩 다른 객체를 생성하는 프로토타입 디자인 패턴에서 이를 어떻게 활용할 수 있을지 살펴봤다
- 이제 객체를 더욱 잘 다루기 위해 생성 디자인 패턴을 사용하는 법을 이해했을 것임
- 3장에서는 디자인 패턴의 두번쨰 종류인 구조패턴을 다룰 것
- 이 패턴은 보다 확장성 있고 유지 보수가 용이한 객체 간 계층 구조를 만들 대 도움이 될 것임


