# 2. 생성 패턴 사용
- 2장에서는 코틀린을 이용하여 고전 패턴의 한 종류인 생성패턴을 구현하는 방법을 살펴볼 것
- 생성 패턴은 '언제', 그리고 '어떻게' 객체를 '생성' 할지에 관한 디자인 패턴임
- 2장에서는 생성 패턴에 속하는 각 디자인 패턴이 해결하고자 하는 문제가 무엇이며, 코틀린에서 어떻게 그 목표를 달성하는지 배울 것

## 생성 패턴의 종류
- 싱글톤 패턴
- 팩토리 메서드 패턴
- 추상 팩토리 패턴
- 빌더 패턴
- 프로토타입 패턴
> 이 디자인 패턴들을 마스터하면 객체를 더 잘 관리할 수 있을 뿐 아니라 변경에 쉽게 대응하며 유지 보수하기 쉬운 코드를 작성할 수 있음

## 싱글톤 패턴
- 디자인 패턴을 별로 좋아하지 않는 사람조차도 싱글톤이란 이름 정도는 안다.
- 일반적으로 어떤 클래스가 있으면 원하는 만큼 인스턴스를 만들어 낼 수 있다.
- 예를 들어 나와 당신이 좋아하는 영화의 목록을 리스트로 만들어본다
```
val myFavoriteMovie = listOf("블랙호크다운", "블레이드 러너")
val yourFavoriteMovie = listOf(...)
```
- 별 문제없이 List인스턴스를 원하는 만큼 만들 수 있는데 클래스는 이런식으로 여러 인스턴스를 가질 수 있다.
- 싱글톤 디자인 패턴의 요구 사항은 두가지다.
  - 시스템에 인스턴스가 딱 하나만 존재해야 한다.
  - 시스템에 모든 부분에서 인스턴스에 접근할 수 있어야 한다.
- 자바를 비롯한 여러 언어에서 이 요구사항을 만족시키는 것은 꽤나 복잡한 문제이다. 먼저 클래스의 생성자를 private으로 만들어서 새로운 인스턴스가 생성되지 않도록 해야한다.
- 그리고 인스턴스 생성이 게으르고 스레드 안전하며 성능을 저해햐지 않도록 해야한다.
- 각 요구사항을 자세히 설명하면 다음과 같다.
  - 게으른 인스턴스 생선
    - 프로그램이 시작되지마자 싱글톤 인스턴스가 만들어지면 안됨
    - 인스턴스 생성에 많은 비용이 들 수 있기 대문.
    - 인스턴스 생성은 필요한 첫 순간에 이루어져야 한다
  - 스레드 안전한 인스턴스 생성
    - 두 스레드가 동시에 싱글톤 객체를 생성하려고 할 때 두 스레드가 같은 인스턴스를 획득해야 한다
    - 이 개념이 익숙하지 않은 독자를 위해 5장에서 자세히 설명할 것
  - 고성능의 인스턴스 생성
    - 많은 스레드가 동시에 싱글톤 객체를 생성하려고 할 때 스레드를 너무 오래 기다리게 하면 안됨
    - 잘못하면 실행이 중단될 수 있다.
- 코틀린에는 싱글톤 객체 생성을 쉽게 할 수 있도록 object라는 키워드가 도입됨
- 스칼라에도 같은 키워드가 존재한다.
- object 키워드를 사용하면 위의 모든 요구사항을 만족하는 싱글톤 객체를 구현할 수 있다
```
object 키워드에는 싱글톤 객체 생성 말고도 다른 쓰임새가 있다. 2장 뒷부분에서 더 자세히 설명할 것
```
- 싱글톤 객체는 일반적인 클래스와 동일한 방법으로 선언하되 생서자는 정의하지 않는다.
- 싱글톤 객체는 직접 인스턴스화 할 수 없기 때문
```
object NoMovieList
```
- 이제 NoMoviesList는 코드 어디서든 접근할 수 있으며 딱 1개의 객체만 존재할 것임
- 예제
```
val myFavoriteQuickAndAngryMovie = NoMovieList
val yourFavoriteQuickAndAngryMovie = NoMovieList
println(myFavoriteQuickAndAngryMovies === yourFavoriteQuickAndAngryMovies)
//true
```
- 두 변수가 메모리상의 같은 객체를 가리키는지 확인하기 위해 참조 동등성 비교 연산자를 사용함 근데 NoMovieList가 리스트이긴 한가?
- 영화 리스트를 출력하는 함수를 작성해보자
```
fun printMovies(movies: List<String>){
    for (m in movies){
        println(m)
    }
}
```
- 처음에 만든 영화 리스트를 전달하면 잘 컴파일 됨
```
//한줄에 하나씩 영화 제목을 출력
printMovies(myFavoriteMovies)
```
- 그러나 싱글톤으로 만든 빈 영화 리스트를 전달하면 아래와 같이 됨
```
printMovies(myFavoriteQuickAndAngryMovies)
// Type mismatch: ingerred type is NoMoviesList but
// List<String > was expected
```
- 영화 리스트 출력 함수는 인수로 문자열 리스트만 받을 수 있는데 NoMoviesList가 문자열 리스트라는 정보는 아무 데도 없기 때문에 (이름에서 유추할 수는 잇으나)오류가 발생한다.
- 다행히 코틀린에서는 싱글톤 객체도 인터페이스를 구현할 수 있음
- 그리고 제네릭 리스트를 나타내는 인터페이스가 존재함
```
object NoMoviesList : List<String>
```
- 이제 필수 함수를 구현하라는 메시지가 뜰 것
- 싱글톤 객체에 본문을 추가해서 필수 함수를 구현
```
object NoMoviesList : List<String>{
    override val size = 0
    override fun contains(element: String) = false
}
```
- 빈 리스트를 만들시 타입에 관계없이 코틀린의 emptyList() 함수 사용
- 싱글톤 객체는 클래스와 결정적으로 다른 부분이 있는데, 생성자를 가질 수 없다는 점
- 싱글톤 객체 초기화가 필요하다면(예를들어 처음에 설정 파일에서 데이터를 읽어와야 한다면)
- 다음과 같이 init 블록을 사용할 수 있음
```
object  logger {
    init {
        println("싱글톤 객체에 처음 접근하였다")
        // 여기에 초기화 로직 작성
    }
}
```
- 만약 싱글톤 객체에 한번도 접근하지 않는다면 초기화 로직은 실행되지 않고 따라서 자원이 절약됨
- 이를 게으른 초기화라고 함
- 객체의 생성을 제한하는 방법을 배웠으니 다음으로는 생성자를 직접 사용하지 않고 객체를 생성하는 방법을 살펴본다