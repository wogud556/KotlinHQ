## 경량패턴
- 경량 객체란 매우 가벼운 객체라는 뜻
- 상태를 갖지 않는 객체를 말함
- 1장,2장을 읽었다면 매우 가벼운 객체의 종류가 하나 떠오를 것임
- 바로 데이터 클래스이다
- 하지만 데이터 클래스는 반대로만 상태만 갖는 객체

#### 경량패턴과 데이터 클래스의 상관관계
- 경량패턴의 역사는 지금이랑 다른 크기의 메모리를 사용하던 시대때문에 경량 패턴을 사용하던 일이 많았다.
- 자원을 효율적으로 사용하는 것은 예나 지금이나 중요한 일이니 어떻게 경량패턴으로 자원을 아낄 수 있는지 알아볼것

### 보수적으로 접근하기
- 2D 횡스크롤 아케이드 플랫폼 게임을 개발한다고 상상해보자
- 방향키나 게임패드를 이용해 캐릭터를 제어할 수 있고 캐릭터는 왼쪽이나 오른쪽으로 움직이며 점프할 수도 있음
- 이 게임을 개발하고 있는 작은 인디 게임 개발 팀은 개발자인 나와 고양이 두마리, 마이클이란 이름의 카나리아 한마리 밖에 없다(대충 혼자란 뜻)
- 그래서 이 게임에는 16가지 색만 사용하려고 함
- 또한 게임 캐릭터의 크기는 가로 세로가 64픽셀
- 이 캐릭터는 여러 종류의 몬스터와 싸우는데, 대부분 육식성의 탄자니아 달팽이임
```
class TanzanianSnail
```
- 2D게임이기 때문에 달팽이도 모두 왼쪽이나 오른쪽으로만 움직일 수 있음
- 다음과 같은 enum클래스를 사용하면 방향을 나타낼 수 있음
```
enum class Direction{
    LEFT,
    RIGHT
}
```
- 화면에 달팽이 몬스터를 그리기 위해서는 각 객체는 이미지와 방향을 들고 있을 것
```
class TansanianSnail{
    val directionFacing = Direction.LEFT
    val sprites = listOf(File("snail-left.jpg"),
                         File("snail-right.jpg"))
    // 달팽이의 상태를 나타내는 다른 속성(체력 등)을
    // 여기에 구현
}
```
> File 클래스는 java.io.File에 정의되어 있음
> 예제 코드에서 어떤 패키지를 Import해야 하는지 궁금하다면 깃허브 저장소를 확인할것
- 달팽이의 현재 방향에 대응하는 아이콘 이미지(sprite)를 가져온다
- 이 이미지를 화면에 그리면 플레이어는 달팽이가 어느 쪽을 향하고 있는지 알 수 있음
```
fun getCurrentSprite(): File{
    return when (directionFacing){
        Direction.LEFT -> sprites[0]
        Direction.RIGNT -> sprites[1]
    }
}
```
- 몬스터가 움직일 땐 그냥 위치를 왼쪽이나 오른쪽으로 한 칸씩 이동해주면 된다
- 이번에는 달팽이의 이동을 애니메이션으로 나타내기 위해 여러 아이콘 이미지를 사용하고 싶다.
- 다음과 같이 List생성 함수를 이용해서 아이콘 이미지 리스트를 생성할 수 있다.
```
class TansanianSnail {
    val directionFacing = Direction.LEFT
    val sprites = List(8) { i -> 
        File(when(i) {
            0 -> "snail-left.jpg"
            1 -> "snail-right.jpg"
            in 2..4 -> "snail-move-left-${i-1}.jpg"
            else -> "snail-move-right${(4-i)}"
        })
    }
}
```
- 이 코드에서 블록 함수를 List 함수에 전달해서 8개의 원소를 갖는 리스트를 생성함
- 이 방법은 복잡한 로직을 사용해 자료구조를 초기화할 수 있으면서도 실질적으로 불변인 객체를 만들 수 있다는 장점이 있음
- 각 원소마다 어떤 이미지를 가져올지는 다음과 같이 결정됨
  - 0번과 1번 원소는 각각 왼쪽과 오른쪽을 향하고 있는 정지 상태의 이미지
  - 2번부터 4번까지의 원소는 왼쪽으로 움직이는 이미지
  - 5번부터 7번까지의 원소는 오른쪽으로 움직이는 이미지임
- 잠깐 계산기를 두드려보면 달팽이 이미지 한 장은 64*64 픽셀임
- 1픽셀이 딱 1바이트라고 가정하면 이미지 한장은 메모리 상에서 4KB를 차지할 것
- 달팽이 객체는 하나당 여덟장의 이미지를 들고있기 때문에 총 32KB를 차지하게 되고, 1MB용량의 메모리는 달팽이를 32마리밖에 올릴 수 없음
- 개발 팁은 이 무시무시하고 날쌘 몬스터가 1000마리 정도는 출몰하기를 원함
- 또한 이 게임은 10년 된 휴대전화에서도 구동 가능해야 함
- 확실한 개선이 필요하다.

### 메모리 절약하기
- 달팽이 클라스가 갖고 있는 문제는 무엇인가?
- 달팽이가 너무 뚱뚱하고 무겁다는 것
- 다이어트를 시켜야 함
- 그러나 사실 모든 객체가 들고 있는 이미지는 동일하다
- 이렇게 생각할 수 있다
- 달팽이 아이콘 이미지를 싱글톤 객체나 팩토리 메서드로 추출하고 각 달팽이 객체는 이를 참조하도록 하면 어떨까?
```
object SnailSprites{
    var sprites = List(8) { i ->
        java.io.File(when(i){
            0 -> "snail-left.jpg"
            1 -> "snail-right.jpg"
            in 2..4 -> "snail-move-left-${i-1}.jpg"
            else -> "snail-move-right${(4-i)}.jpg"
        }

        )

    }
}

class TansanianSnail(){
    val directionFacing = Direction.LEFT
    val sprites = SnailSprite.sprites
}
```
- 이렇게 하면 getCurrentSprite함수는 고칠 필요가 없음
- 또한 달팽이 객체를 얼마나 많이 생성하든 총 메모리 사용량은 256KB에 불과함
- 이제 메모리 걱정없이 수백마리의 달팽이를 만들 수 있음
- 이것이 바로 경량 패턴의 핵심
- 즉 무거운 객체(예제에서는 이미지 파일)를 제한적으로만 생성하고 경량 객체(예제에서는 달팽이 객체)들이 무거운 객체를 공유하도록 하는 것

### 경량 패턴 사용 시 주의 사항
- 전달하는 데이터의 불변성을 특별히 신경 써야 함
- 가령 snailSprites객체에서 val대신 var을 사용했다면 재앙이 벌어질 수 있음
- 가변 리스트도 사용하면 안된다
- 누군가 이미지를 지우거나 다른 이미지로 교체하면 큰일이기 때문
- 다행히 코틀린에서는 이런 상황을 쉽게 방지할 수 있음
- 항상 외부 상태는 변수 대신 값으로 선언하고 일단 만들어지면 변경이 불가능한 불변 자료 구조를 사용한다
- 메모리가 넘처나는 시대에 경량 패턴이 왜 필요하나 물을 수 있다
- 하지만 앞서 말했듯 도구 상자에 다룰 수 있는 도구를 하나 더 쟁여둔다고 나쁠 것은 없다
- 언젠간 쓸모가 생길 수 있음

