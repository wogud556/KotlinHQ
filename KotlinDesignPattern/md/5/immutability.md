### 불변성
- 함수형 프로그래밍의 근간을 이루는 개념 중 하나는 불변성
- 불변성이란 함수가 입력을 받는 순간부터 값을 변환하는 순간까지 객체가 변하지 않는 속성을 말함
- 그렇게 변한다는 것은 어떤것인가? 아래 예제를 보자
```
fun <T> printAndClear(list: MutableList<T>){
    for(e in list){
        println(e)
        list.remove(e)
    }
}
priuntAndClear(mutableListOf("a","b","c"))
```
- 이 코드는 먼저 a를 출력할 것
- 그러고는 ConcurremtModificationException 예외를 던짐
- for-in 반복문은 반복자를 사용하는데(반복자는 4장에서 다룸) 리스트를 반복문안에서 수정하면 반복자의 동작이 방해를 받게 되기 때문에 이러한 예외가 발생하는 것
- 그렇다면 애초에 이런 런타임 예외가 발생하지 않도록 보호장치를 만들 수 없나 라는 의문이 생김

### 불변 자료 구조
- 코틀린의 집합 자료 구조는 기본적으로 불변이라는 점을 설명함
- 다른 언어들과 다른 부분중 하나
- 앞의 예제 코드에서는 단일 책임 원칙을 따르지 않아 문제가 발생함
  - 단일 책임 원칙이란 하나의 함수는 하나의 일만 해야 하며, 그 일을 잘해야 한다는 원칙
- 문제의 함수는 원소를 배열에서 제거하는 일과 출력하는 일, 두가지를 모두 하려고 하고 있음
- 이 함수의 인수를 MutableList에서 List로 변경하면 remove() 함수를 호출할 수 없기 때문에 문제가 해결됨
- 하지만 함수의 결괏값으로 빈 리스트가 필요한 경우?
- 이럴 땐 함수가 새로운 객체를 반환하도록 해야 함
```
private fun<T> printAndClear(list : MutableList<T>):
    MutableList<T> {
        for(e in list) {
            println(e)
        }
        return mutableListOf()
    }
```
- 일반적으로 함수형 프로그래밍에서 반환값이 없는 함수는 작성하지 않아야 함
- 반환값이 없다는 것은 보통 부수 효과가 있다는 것을 의미하기 때문
- 하지만 자료구조가 불변인 것만으로는 충분하지 않다.
- 자료구조의 내용물 역시 불변이어야 함
- 무슨 뜻인지 이해하기 위해 다음의 간단한 클래스를 본다
```
data class Player(var score:Int)
```
- 이 클래스는 score라는 변수 하나만을 갖고 있음
- 다음으로는 이 데이터 클래스의 인스턴스를 하나 만들어서 불변 자료 구조에 넣을 것
```
val scores = listOf(Player(0))
```
- 인스턴스를 여러개 만들어서 넣을 수도 있지만 요점을 설명하기 위해서는 하나로 충분함
- 다음 절에서는 스레드의 개념을 소개할 것

### 공유된 가변 상태의 문제점
- 스레드에 익숙하지 않더라도 6작에서 자세히 설명할 테니 크게 걱정안해도됨
- 지금 알아야 하는 것은 스레드를 통해 코드를 '동시에' 실행할 수 있다는 것
- 이렇게 여러 CPU를 사용하는 동시성 코드를 활용할 때 함수형 프로그래밍이 빛을 발함
- 동시성이 전혀 개입되지 않은 예제는 다소 복잡하거나 인위적으로 보일 수 있음
- 지금은 2개의 스레드를 담고 있는 리스트를 만들어본다.
```
val threads = List(2) {
    thread {
        for(i in 1..1000){
            scores[0].score++
        }
    }
}
```
- 각 스레드가 평범한 for반복문을 사용해서 score 변수의 값을 1000씩 증가시키는 것을 볼 수 있음
- join() 함수를 사용하면 스레드가 끝나길 기다릴 수 있고 그 후에는 score값을 확인할 수 있음
```
for(t in threads) {
    t.join()
}
println(scores[0].score) // 2000보다는 작은 값
```
- 직접 코드를 실행해 보면 2000보다 작은 어떤 값이 출력될 것
- 이것은 가변 변수를 사용할 떄 발생하는 경합 조건을 보여주는 고전적인 예시
- 동시성 프로그래밍 경험이 있다면 왜 이런 일이 발생하는지 금방 알 수 있을 것
- 각 스레드가 할당된 일을 끝까지 수행하지 못헀기 때문에 문제가 생긴 것으 ㄴ아님
- 이를 확인하기 위해 반복문 끝에 완료 메시지를 출력한다.
```
thread {
    for (i in 1..1000) {
        scores[0].score = scores[0].score + 1
    }
    println("완료")
}
```
- 즈가 연산자(++)의 잘못도 아님
- 위의 코드에서는 보다시피 증가 연산자를 풀어서 길게 썼지만 여러 번 실행해 보면 여전히 틀린 결과가 출력될 것
- 이 문제의 진짜 이유는 더하기 여산과 할당 연산이 원자적이지 않다는 데에 있음
- 두 스레드가 서로의 더하기 연산 결과를 덮어써 버릴 수 있기 때문에 값이 원하는 만큼 증가하지 않는 것
- 여기서는 원소가 하나만 들어 있는 자료구조를 사용해 극단적인 예시를 들음
- 그러나 실무에서는 일반적으로 많은 원소가 들어있는 자료 구조를 사용할 것
- 예를 들어 여러 플레이어의 점수를 저장하거나 동시에 수천명의 플레이어의 순위를 매기는 일을 해야 함
- 그러면 훨씬 더 복잡한 상황이 펼쳐질 것
- 다음을 기억한다. 자료구조가 불변이어도 거기에 들어있는 원소는 가변 객체일 수 있음
- 가변 객체는 스레드 안전하지 않음
- 다음으로는 불변 객체 중 하나인 튜플이다.


### 튜플
- 함수형 프로그래밍에서 튜플은 일단 생성되면 변경이 불가능한 자료를 나타냄
- 코틀린에서 가장 기본적인 튜플은 pair임
```
val pair = "a" to 1
```
- pair는 first와 second라는 2개의 속성을 가지며 불변임
```
pair.first = "b"
pair.second = 2
```
- 분해 선언을 사용하면 pair를 두 값으로 분리할 수 있음
```
val(key, value) = pair
println("$key => $value")
```
- 맵을 순회할 때는 Map.Entry라는 또 다른 튜플을 사용함
```
for(p in mapOf(1 to "일요일", 2 to "월요일")) {
    println("${p.key} ${p.value}")
}
```
- 이 튜플은 first와 second가 아니라 key와 value라는 멤버를 갖고 있음
- pair 말고 Triple이라는 튜플도 있는데 여기는 first, second와 함께 third라는 멤버도 있음
```
val secondEdition = Triple("코틀린 디자인 패턴 2/e",396, 2023)
```
- 일반적으로 데이터 클래스는 멤버의 이름이 의미를 잘 나타내기 때문에 좋은 튜플이 될 수 있음
- 확실히 위의 예제에서 396이라는 수가 쪽수를 나타낸다는 것을 바로 알아차피긴 어려움
- 하지만 이전 절에 봤듯이 모든 데이터 클래스가 튜플인 것은 아님
- 모든 멤버가 변수가 아닌 값이어야 함
- 또한 자료 구조나 클래스 타입의 멤버는 모두 불변이어야 함
- 이제 함수형 프로그래밍에서 중요한 또 하나의 주제를 살펴볼 것
- 바로 일급 객체로서의 함수 개념