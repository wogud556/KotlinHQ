## 팬아웃 패턴
- 작업을 여러 동시성 프로세스(일꾼이라고도 함)을 배분하기 위한 패턴임
- 이해를 돕기 위해 이전 절에서 다뤘던 예제에 다음과 같은 새로운 문제 상황이 생겼다고 해본다.
- 파이프라인의 처리 단계마다 수행해야 하는 작업의 양이 크게 다르다면
- 예를들어 HTML문서를 파싱하는 것보다 네트워크를 통해 받아오는 데에 시간이 훨씬 오래 걸림
- 이런 경우 오래 걸리는 작업을 여러 코루틴에 분배하기를 원하르 수 있음
- 앞의 예제에서는 코루틴 하나가 채널 하나를 읽어 드림
- 그러나 여러 개의 코루틴이 하나의 채널을 읽는 것도 가능
- 이렇게 하면 일감을 나눠서 처리할 수 있게 됨
- 설명을 간단하게 하기 위해 어던 값을 생산하는 코루틴을 다음과 같이 하나만 만들어본다.
```
fun CoroutineScope.generateWork() = produce {
    for( i in 1..10_000) {
        send("${i}쪽")
    }
    close()
}
```
- 그리고 다음 함수는 생산자가 생산한 값을 읽는 코루틴을 생성하는 역할을 함
```
fun CoroutineScope.doWork(
    id : Int,
    channel: ReceiveChannel<String>
) = launch(Dispatchers.Default) {
    for (p in channel) [
        println("${id}번 일꾼이 ${p}을 처리")
    ]
}
```
- 이 함수는 Default 분배기에서 실행되는 코루틴을 생성함
- 각 코루틴은 어던 채널을 보고 있다가 값이 들어오면 콘솔에 그 값을 출력함
- 이제 생산자를 시작해본다.
- 다음 코드는 모두 runBlocking함수 안에 있어야 한다는 것을 기억한다.
- 하지만 여기서는 중요한 부분에 집중할 수 있도록 생략함
```
val workChannel = generateWork()
```
- 이제 다음과 같이 여러 일꾼이 같은 채널을 읽도록 하면 작업을 분배할 수 있게 됨
  
```
val workers = List(10) {
    id -> doWork(id, workChannel)
}
```
- 이제 이 프로그래밍 어떤 출력을 내는지 일부를 살펴본다.
```
>...
> 4번 일꾼이 9994쪽을 처리
> 8번 일꾼이 9993쪽을 처리
> 3번 일꾼이 9992쪽을 처리
> 6번 일꾼이 9987쪽을 처리
```
- 두 일꾼이 같은 메시지를 받는 일은 없음
- 또한 전송 순서와 출력 순서가 일치하지 않는다는 점도 유념
- 팬아웃 패턴은 작업을 여러 코루틴, 스레드, CPU에게 효율적으로 분배할 때 유용하게 사용할 수 있음
- 다음은 팬아웃 패턴의 짝꿍이라고 할 수 잇는 팬인 패턴을 알아본다
- 팬인 패턴은 팬 아웃 패턴과 쌍으로 사용될 때가 많음
