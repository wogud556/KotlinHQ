## 대수 자료형 구현
- 대수형 자료형은 함수형 프로그래밍에서 사용하는 개념인데, 3장에서 배운 합성 디자인 패턴과 매우 유사
- 코틀린으로 간단한 이진 트리를 구현면서 대수적 자료형의 사용법과 장점을 살펴본다.
- 인터페이스에 sealed 키워드를 붙인 것도 볼 수 있음
- 일반적인 클래스에 Sealed 키워드를 적용하는 것은 4장에서 방문자 패턴을 다루면서 살펴봄
- 하지만 인터페이스에 sealed를 붙이는 것은 비교적 새로운 기능이며 코틀린 1.5에서 처음 도입됨
- 의미는 일반적인 클래스와 같음
- 인터페이스의 소유자만 이를 구현할 수 있다는 것
- 이는 컴파일 시에 인터페이스의 모든 구현체를 알 수 있다는 뜻
- 다음으로는 빈 트리를 선언해본다.
```
object Empty : Tree<Nothing> {
    override fun toString() = "빈 트리"
}
```
- 모든 빈 트리는 동일하기 때문에 객체로 선언해줌
- 2장에서 배운 싱글톤 디자인 패턴의 사용 례
- 빈 트리의 타입으로는 Nothing을 사용했는데, 코틀린의 객체 계층 구조상의 특수 클래스임
> Any와 Nothing을 혼동하는 경우가 조종 있음
> Any는 자바의 Object처럼 어떤 클래스든 나타낼 수 있지만 Nothing은 아무 클래스도 나타내지 않음
> 여기서 왜 Any를 사용할 수 없는지는 뒤에 설명할 것

- 이제 비어있지 않은 트리 노드를 정의한다
```
data class Node<T> (
    val value: T,
    val left: Tree<T> = Empty,
    val right: Tree<T> = Empty

) : Tree<T>
```
- Node도 Tree 인터페이스를 구현하지만, 이번에는 객체가 아니라 데이터 클래스
- 모든 노드는 다르기 때문
- Node는 T타입의 값을 갖고 있는데, 이는 어떤 타입이든 값이 될 수 있다는 뜻
- 하지만 같은 트리에 속하는 노드는 모두 같은 값 타입을 가져야 함
- 이게 바로 제네릭의 힘
- 이진 트리이기 때문에 하나의 노드는 left와 right라는 2개의 자식을 갖음
- 기본적으로 두 자식은 모두 Empty임
- 자식 노드의 기본값을 Empty로 설정할 수 있었던 거는 값 타입 T가 공변이며 Empty의 값 타입이 Nothing이기 때문
- Any가 클래스 계층의 최상위 클래스에 해당한다면 Nothing은 최하위 클래스임
- Tree의 값 타입을 out T라고 선언하면 이 트리가 T또는 T를 상속하는 모든 타입을 값으로 가질 수 있다는 의미
- Nothing은 클래스 계층의 최하위 클래스이므로 모든 클래스를 상속받음

```
val tree = Node (
    1,
    Empty,
    Node (
        2,
        Node(3)
    )
)
println(tree)
```
- 최상위 노드의 값은 1이며 오른쪽 자식 노드의 값은 2임
- 이 노드는 왼쪽 자식 노드를 가지며 이 자식 노드의 값은 3임
- 그림으로 표현하면 9.1과 같음
```
## 대충 그림이라고 친다
1->2->3
```
- 이 코드의 출력은 다음과 같음
```
> Node(value = 1, left=Empty, right = Node(value=2, left=Node(value=3, left=Empty, right=Empty), right=Empty))
```
- 하지만 트리를 이런 식으로 출력하는 것은 별로 쓸모가 없음
- 조금 더 유용한 정보를 얻기 위해 트리가 정수 값을 가질 때 모든 노드의 값을 더하는 함수를 구현해본다.
```
fun Tree<Int>.sum(): Long = when(this) {
    Empty -> 0
    is Node -> value + left.sum() + right.sum()
}
```
- 이를 대수적 자료형에 대한 연산이라고 부름
- 정수를 값으로 갖는 트리에 대해서만 선언한 확장 함수
- 우선 각 노드가 Empty인지 Node인지 확인함
- sealed 클래스와 인터페이스의 아름다움이 여기서 돋보임
- Tree 인터페이스의 구현체가 딱 2개밖에 없다는 사실을 컴파일러가 알고 있기 때문에 when표현식에 else 블록을 작성할 필요가 없음
- 만약 Empty 노드라면 기본값 0을 반환함
- Empty가 아니라면 왼쪽과 오른쪽의 자식의 값을 자신의 값과 더해서 반환함
- 이 함수는 5장에서 다룬 재귀 알고리즘의 예시 이기도 함
