## 코틀린 동시성 프로그래밍 공부
---
### 1장 학습내용
- 프로세스, 스레드, 코루틴 및 이들의 관계
- 동시성
- 동시성 대 병렬성
- CPU 바운드 및 I/O 바운드 알고리즘
- 동시성이 망설여지는 이유
- 코틀린의 동시성
- 개념과 용어

### 프로세스, 스레드, 코루틴
- 프로세스
  - 프로세스는 실행중인 애플리케이션의 인스턴스
  - 애플리케이션이 시작될 때마다 애플리케이션의 프로세스가 시작
  - 프로세스는 상태를 갖고 있다.
  - 리소스를 여는 핸들, 프로세스 ID, 데이터, 네트워크 연결 등은 프로세스 상태의 일부이며 해당 프로세스 내부의 스레드가 엑세스를 할 수 있다.
- 스레드
  - 실행 스레드는 프로세스가 실행할 일련의 명령을 포함한다.
  - 프로세스는 최소한 하나의 스레드를 포함, 이 스레드는 애플리케이션의 진입점을 실행하기 위해 생성된다.
  - 보통 진입점은 애플리케이션의 main() 함수이며 메인 스레드라 하는데 프로세스의 라이프 사이클과 밀접하게 연관된다.
  - 스레드가 끝나면 프로세스의 다른 스레드와 상관없이 프로세스가 종료된다.
  - 예시코드 -> main 함수에서 dowork이란 함수를 호출, do work라는 함수가 종료되면 애플리케이션의 실행이 종료
  ```
    fun main(args: Array<String>){
        doWork()
    }
  ```
  - 각 스레드는 스레드가 속한 프로세스에 포함된 리소스를 엑세스하고 수정할 수 있지만 스레드 로컬 스토리지라는 자체 저장소도 갖고 있따.
  - 스레드 안에서 명령은 한번에 하나 실행
  - 스레드가 블록되면 블록이 끝날 때 까지 같은 스레드에서 다른 명령을 실행할 수 없다.
  - 다만 많은 스레드는 같은 프로세스에서 생성이 가능하며, 서로 통신할 수 있다.
  
- 코루틴
  - 경량 스레드라고 한다.
  - 프로세스가 실행할 명령어의 집합의 실행을 정의하기 때문이다.
  - 코루틴은 스레드와 비슷한 사이클을 가지고 있음
  - 코루틴은 스레드 안에서 실행되며, 스레드 하나에 많은 코루틴이 있을 수 있지만, 주어진 시간에 하나의 스레드에서 하나의 명령어만이 실행될 수 있다.
  - 같은 스레드에 10개의 코루틴이 있다면 해당 시점에는 하나의 코루틴만 실행된다.
  - 스레드와 코루틴의 차이는 코루틴이 빠르고 적은 비용으로 생성할 수 있다는 것. 수천개의 코루틴도 쉽게 생성할 수 있으며, 수천개의 스레드를 생성하는 것보다 빠르고 자원도 훨씬 적게 사용
  - 예제코드
  ```
  suspend fun createCoroutines(amount: Int){
    val jobs = ArrayList<Jop>()
    for (i in 1..amount){
      jobs += launch{
        delay(1000)
      }
    }
    jobs.forEach{
      it.join()
    }
  }
  ```
  - 해당 함수는 파라미터 amount에 지정된 수만큼 코루틴을 생성해 각 코루틴을 1초간 지연시킨 후 모든 코루틴이 종료될 떄 까지 기다렸다가 반환한다.
  