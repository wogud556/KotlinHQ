- 코틀린 디자인패턴 책

## 1장 코틀린 시작하기

### 명명규칙
- 우선 코틀린은 .kt 로 끝나는 소스이다
- 파일명은 클래스명과 동일하게 짓는다 패턴은 그뒤에
- 파일명에는 카멜 케이스를 사용한다(책에서 나온 내용임)
  * 카멜케이스란? : 맨 앞 단어기준문자제외 그이후 단어단위 앞쪽에 대문자를 사용하여 이름을 읽기 쉽게 지음
- 메인은 대부분 Main.kt 임

## 패키지
- 비슷한 목적 또는 도메인을 공유하는 파일과 클래스의 묶음
- 자바랑 비슷하게 아래와 같이 키워드를 시용
```
//package 대단위.중단위.소단위
```
- 자바와 동일하게 간다고 생각하면 됨
- Main.kt 에서는 패키지를 선언하지 않아도 됨

### 주석
// 한줄
/**/ 여러줄

### Hello Kotlin
```
//국룰 소스코드

fun main(){ // 코틀린은 fun 키워드로 함수 사용
	println(“hello kotlin”) // 자바처럼 앞 패키지 선언은 안해도 된다
}
```
### 감싸는 클래스가 없음
- 코틀린에는 패키지 수준 함수라는 개념이 있음
- 클래스 속성에 접근할 필요가 없는 함수라면 굳이 클래스로 감싸지 않아도 된다는 것
- 책의 뒷부분에서 패키지 수준 함수에 대해 더 자세히 살펴볼 것

### 명령줄 인수가 없음
```
public static void main(String [] args) {…} // 명령줄 인수 선언코드
```

### static 키워드가 없음
- 어떤 언어에서 클래스를 인스턴스화 하지 않고도 실행할 수 있는 함수를 나타내기 위해 static을 사용
- 코틀린에서는 상태를 갖지 않는 함수는 클래스 밖에 두면 됨
- 그래서 코틀린에는 static 키워드가 없음

### 더 간결한 출력함수
- println() //ㅈㄱㄴ

### 세미 콜론이 없음
- 자바나 다른 언어에서는 세미콜론 사용하는 빈도가 많다
코틀린은 세미콜론 없음

## 타입 이해하기

### 기본 타입
- 어떤 언어에서는 원시타입 (primitive type) 객체로 구분
- 코틀린에서는 그런 구분 자체가 없다 모든 타입에서 동등함
- 대부분의 타입은 자바와 비슷
- 예외로 친다면 자바의 Integer는 코틀린에서 Int임
- 자바의 Void 는 코틀린에서 Unit임

#### 예시
- 수
  - Int, Long, Double
- 문자열
  - String
- 부울
  - Boolean
- 문자
  - Char

### 타입추론
```
var greeting = “hello Kotlin”
Println
```
- 이 다음 코드에서 오류를 발생시킬 수 있다
```
greeting = 1
// 코틀린에서는 자동으로 타입 추론을 하므로 자료형 선언이 되어있지 않다 하더라도 숫자형으로 맘대로 바꿀 수 없음
```
- 오류가 발생하는 이유는 변수의 타입을 딱 한번만 정의하기 때문
- 만약 변수를 명시적으로 선언하려고 한다면 아래와 같이 선언한다.
```
var greeting : String = “hello Kotlin”
```

### 값
- 자바에서는 변수를 final로 선언할 수 있음
- sfinal 변수는 딱 한번만 할당되고 이 변수에 대한 참조는 사실상 불변(immutable)
```
final String s = “hi”;
s = “Bye”;
```
- 코틀린에서 이 방법을 한번에 바꿔버리는 방법이 있다
- val을 사용하는 방법
- var와 val의 차이라고 할 수 있으며 val은 불변된 값 지정이 가능하다
```
val greeting = “Hi”//final 과 같은 역할을 한다.
greeting = “Bye”//불가능
```
- 변수보다 값을 더 사용하는 것이 바람직한데, 불변 데이터가 값을 추적하기 알맞기 때문


### 비교와 동등성
- 자바에서는 객체끼리 비교시 == 연산자를 사용하면 원하는 결과를 얻지 못한다는 것을 익히 알고 있을것
- == 연산자는 두 객체가 동등한지 비교하는 대신 두 포인터가 같은 객체를 바라보고 있는지 비교하기때문
- 대신 자바 객체비교에 equals()를 사용하고, ==는 원시타입 변수끼리 비교할때만 사용함
- 코틀린 또한 ==연산자를 equals()로 해석한다
- 참조 동등성을 확인하려면 === 을 사용
- 그러나 기본타입 중에는 참조 동등성 비교가 불가능한 타입도 있음.

### 함수선언
- 자바에서 모든 메서드는 클래스나 인터페이스 안에 있어야 함
- 클래스나 인터페이스의 정보를 전혀 사용하지 않더라도 그렇다
- 코틀린에서는 클래스 바깥에도 함수를 선언할 수 있다. main()함수가 그런 케이스임
- 함수를 선언할 때 fun 키워드를 사용한다.
- 인수의 경우 인수 앞이 아니라 뒤에 온다.
```
fun greet(greeting: String){
	println(greeting)
}
```
- 결과를 반환해야 한다면 반환형은 함수 선언 뒷부분에 기술
```
fun getGreeting():String{
	return “Hello, Kotlin!”
}
```
```
// 아래 코드도 직접 실행해보자
fun main(){
	greet(getGreeting())
}
```
- 함수가 아무것도 반환하지 않는다면 반환형은 아예 생략할 수 있다
- 즉 void 타입(코틀린상에서 Unit)으로 선언할 필요가 없음
- 함수가 식 하나로 표현될 만큼 짧다면 (위의 getGreeting()함수같이) 반환형과 중괄호를 지우고 다음과 같이 더 짧게 쓸 수 있다
```
fun getGreeting() = “hello, Kotlin”
```
- 이 때 코틀린 컴파일러는 함수가 String 타입을 반환하는 것을 추론할 것
- 어떤 스크립트 언어에서는 함수 선언 순서가 중요하나, 코틀린에서는 아님
- 가령 예제 코드의 main 함수는 시야에 있는 모든 함수를 호출할 수 있음
- Main 함수는 시야의 모든 함수를 호출 할 수 있음
- main 함수보다 뒤에 선언됐더라도 호출할 수 있음

### null 안전성
- nullpointException 이 발생되는 주 원인은 어떤 객체든 null일 수 있기 대문에 발생된다
- 이러한 문제를 해결하기 위해 자바 8에서는 새로운 클래스인Optional 을 사용하여 값이 없을 수 있다는 것을 표현할 수 있다.
```
var optional = Optional.of(“null 이 아닌 문자열”)
if(optional.isPresent()){
	System.out.println(optional.get().length());
}
```
- 그러나 인수로 받는 함수도 null를 전달할 수 있고 그렇게되면 런타임 오류가 발생된다.
```
void printLength(Optional<String> optional) {
	if(optional.isPresent()){
		System.out.println(optional.get().length());
	}
}
PrintLength(null);
```
- 코틀린의 경우 컴파일 시 null 검사를 수행함
```
val s: String = null // 컴파일 불가
```
- 아래 코틀린으로 작성된 PrintLength() 함수가 있다
```
fun printLength(s: String){
	println(s.length)
}
```
- 위 함수에 Null 을 전달하면 컴파일이 되지 않음
```
printLength(null)
// “Null cannot be a value of a non-null type String” 오류 발생
```
- 만약에 null을 받고 싶다면
```
fun printLength(stringOrNull : String?){…}
```
- 위 코드와 같이 자료형 뒤에 ?를 입력하여 null 이 들어갈 수 있음을 명시함

## 코틀린 자료구조 복습
- 이라고 하기엔 첨본 내용도 많음

### 리스트
- 같은 타입을 갖는 원소의 순서 있는 집합을 이야기함
- 코틀린에서는 list 함수를 사용해서 리스트를 선언함
```
val hobbits = listOf(“프로도”, “샘”, “피핀”, “메리”)
```
- 리스트의 타입을 선언하지 않았다는 점에 주목
- 코틀린에서는 변수를 초기화할 때와 마찬가지로 집합 자료 구조를 만들 때도 타입 추론이 가능하기 때문
- 리스트의 다입을 명시하고 싶다면 함수의 인수 정의와 비슷한 방법으로 사용할 수 있음
```
val hobbits: List<String> = listOf(“프로도”, “샘” , “피핀” , “메리”)
```
- 특정 인덱스로 리스트 원소에 접근할 때는 대괄호를 사용
```
println(hobbits[1])
//코드 실행 시 아래와 같이 출력됨
>샘
```

### 세트
- 세트는 중복없는 원소의 집합
- 세트에서 원솔르 찾는 것은 리스트에서보더 훨씬 빠름
- 리스트와 달리 인덱스에서의 접근은 불가능하다
- 대충 똑같은거 때려박아도 중복이 안되게 출력됨

```
val footballChampions = setOf(“프랑스”, “독일”,“스페인”,“이탈리아”,“브라질”,“프랑스”,“브라질”,“독일”)
println(footballChampions) //[프랑스, 독일, 스페인, 이탈리아. 브라질]
```
- 세트에 어떤 원소가 있는지는 in 함수를 사용함
```
println(입력값 in setOf 변수)
```
- 일반적으로 세트는 원소의 순서를 보장하지 않음
- 그러나 현재 setOf() 함수는 LinkedHashSet을 반환하도록 구현되어있는데, 이 클래스는 원소가 추가된 순서를 보존한다.
- 즉 위의 예제에서 프랑스는 맨 먼저 출력되는데, 이는 입력 순서상 가장 앞에 있었던 까닭임

### 맵
- 맵은 키의 유일성이 보장되는 키-값 쌍의 집합
- 두 원소의 쌍을 만드는 키워드는 to
- 사실 to는 진짜 키워드는 아니고 특별한 함수임
```
val movieBatmans = mapOf(
	“배트맨 리턴즈” to “마이클 키튼”,
	“배트맨 포에버” to “발 킬머”
	“배트맨과 로빈” to “조지 클루니”
)
println(movieBatmans)
```
- 키를 이용해 값을 조회하려면. 대괄호 안에 키를 넣으면 됨
```
println(movieBatmans[“배트맨 리턴즈”])
```
- 부재를 검사하는 기능도 있음
```
println(“배트맨 비긴즈” !in movieBatman)
> true //이런식으로 출력
```

### 가변성
- 여태 소개한 자료구조는 불변임 더 정확히는 읽기 전용임
- listOf() 함수로 만든 리스트에는 새로운 원소를 추가하는 메서드가 없음.
- 원소의 값을 바꿀 수도 없음
- 불변 자료구조는 동시성 코드를 작성할떄 매우 도움이 됨
- 하지만 수정 가능한 자료구조가 필요할 때도 있는데 그러럐ㄸ는 집합 자료 구조를 만드는 함수의 가변 버전을 사용할 수 있음
```
val editableHobbits = mutableListOf("프로도", "샘", "피핀", "메리")
editableHobbits.add("빌보")
```
- 수정 가능한 집합에는 add()같은 함수가 있어서 변경이 가능함. 즉 가변적이다.

### 집합 자료 구조의 다른 구현체
- 이전에 JVM을 사용해 본적이 있다면 세트와 맵에 다른 구현체가 있다는 것을 알 것
- 예를들어 TreeMap은 키를 정렬된 상태로 저장함
```
import java.util.*
//키로 정렬되는 가변 맵

val treeMap = java.util.TreeMap(
    mapOf("첫째돼지" to "지푸라기 집",
        "둘째 돼지" to "나무 집",
        "셋쨰 돼지" to "벽돌 집"
    )
)
println(treeMap.keys)
```
- 다음과 같이 출력될 것
```
> 둘째 돼지, 셋째 돼지, 첫째 돼지
```
- 알고리즘에 써먹어라
- 가나다 순으로 알아서 정렬됨

### 배열
- 이 절에서 꼭 짚고 넘어가야 할 자료구조래
- 자바에서 배열은 대괄호를 사용하는 특별한 문법을 갖고있음
- 코틀린에서는 대괄호 뭐시깽이 말고 컬렉션을 사용함(제네릭 함수)
#### 아래와 같이 선언함
```
val musketeers: Array<String> = arrayOf("아토스", "포르토스", "아라미스")
```
- 코틀린 코드에 처음으로 꺾쇠 괄호가 등장함 
- 자바나 타입스크립트에서 처럼 꺾쇠 괄호가 들어가는 타입을 타입인수라고 함
- 여기선 배열에 문자열이 들어있다는 것을 나타냄
- 4장 제네릭 설명때 다시 이야기함
#### 이미 만들어진 집합 자료 구조를 배열로 변환하고자 한다면 toTypedArray함수를 이용한다.
```
listOf(1,2,3,5).toTypedArray()
``` 
- 기능적인 측면에서 코틀린 배열은 리스트와 매우 유사함
- 예를 들어 코틀린 배열의 원소 갯수를 구하려면 다른 집ㅎ바 구조와 마찬가지로 size속성을 사용
- 언제 배열을 사용해야하나 먼저 main 함수에서 인수를 받을 때
- 앞에 예제에서는 인수 없는 main함수만 봤지만 명령줄 인수를 전달하는 경우도 있음
#### 다음 예제는 명령줄 인수를 받아서 쉼표로 연결한 뒤 출력하는 main함수임
```
fun main(args: Array<String>){
    println(args.joinToString(", "))
}
```
- 배열을 인수로 받는 자바 함수를 호출하거나 varargs 문법을 사용하는 경웽도 배열이 필요함
- 이런 내용은 3장에서 다룸

## 제어흐름
- 프로그램을 작성할 때 제어흐름은 빠질 수 없음, 잘 알고있다시피 if와 when을 주로 사용함

### IF문
```
public String getUnixSocketPolling(boolean isBsd){
    if(isBsd){
        return "Kqueue";
    }else{
        return "epoll";
    }
}
```
- 대충 자바라 소스가 간결하지 못하단 소리
- 코틀린에서는 if가 식이기 때문에 값을 반환할 수 있다.
- 위의 함수를 코틀린으로는 다음과 같이 작성할 수 있음
```
fun getUnixSocketPolling(isBsd: Boolean): String{
    return if (isBsd){
        "kqueue"
    }else{
        "epoll"
    }
}
```
- 더 짧게 작성하면 아래와 같다
```
fun getUnixSocketPolling (isBsd: Boolean): String = if (isBsd) "kqueue" else "epoll"
```
- if가 식이라는 사실 덕분에 지역 변수를 선언하지 않아도 됨
- 여기서도 단일식 함수와 타입 추론을 사용하고 있음
- if가 String타입의 값을 반환하고 있다는 것이 중요한 부분임
- 여러개의 return문을 사용할 필요도 없고, 가변 변수를 사용할 필요가 없다 

## When 조건식
- if문에 더 많은 조건을 넣고 싶다면 어떻게 해야할까
- 자바에서는 switch문을 사용한다. 코틀린에서는 when을 사용함
- when은 코틀린의 다른 기능과 결합해서 사용할 때 훨씬 강력함. 슈퍼히어로의 이름을 넣으면 그의 숙적이 누구인지 알려주는 메소드를 알아보자
```
fun archenemy(heroName : String) = when(heroName){
    "배트맨" -> "조커"
    "슈퍼맨" -> "렉스 루터"
    "스파이더맨" -> "그린고블린"
    else -> "ㅈㅅ 모름"
}
//키포인트는 mapOf때처럼 ,로 구분자를 주는 것이 아닌 그대로 -> 당 하나로 ,를 입력하지 않ㄴ는다 까먹지 말도록
```
- when 조건식은 매우 강력하다. 2장에서 범위, 열거형, 봉인 클래스와 when조건식을 함께 사용하는 법을 자세히 설명할 것
- 일반적으로 셋 이상 조건이 필요하다면 when을 사용하고 단순한 경우에는 if를 사용함

## 텍스트 다루기
- 지금까지 텍스트를 다루는 예제를 확인했다.
- 문자열을 사용하지 않고는 (아주 이상하고 불편한 방법을 사용하지 않는 이상) Hello Kotlin도 출력하지 못하거나 적어도 매우 어색하고 불편했을 것임
- 이 절에는 텍스트를 효율적으로 다루기 위한 기능을 더 심도있게 살펴볼 것임

### 문자열 보간
- 위의 예제에서 만든 하뭇의 결과를 실제로 출력하기를 원한다고 치자
- 이미 앞의 예제들에서 봤겠지만 코틀린은 자바의 장황한 System.out.println 명령을 감싸고 있는 println()이라는 함수를 기본으로 제공함
- 중요한 것은 코틀린이 다른 최신 언어들과 마찬가지로 ${}문법을 활용한 문자열 보간(String Interpolation)을 지원한다는 것임
- 앞의 예제에서 이어지는 다음코드를 보자
```
val hero = "배트맨"
println("$hero, 그의 숙적은  ${archenemy(hero)}")
```
- 이 코드를 실행하면 다음과 같이 나옴
```
> 배트맨, 그의 숙적은 조커
```
- 함수 값을 넣을 때에는 중괄호로 감싸야 한다는 점에서 주의하셈
- 그냥 변수라면 중괄호는 생략할 수 있다

### 여러 줄 문자열
- 코틀린은 여러 줄 문자열(mutiline String, 미처리 문자열이라고도 함)을 지원한다.
- 다른 최신 언어에도 존재하는 기능이며 자바 15에는 텍스트 블록 이라는 이름으로 도입됨
- 개념은 매우 단순함. 여러줄에 걸쳐 있는 텍스트를 출력하고자 함.
- 예를 들어 루이스 캐롤이 지은 "이상한 나라의 앨리스"의 일부분을 출력하자
- 여러 줄을 하나의 문자열로 만들기 위해 다음과 같이 할 수 있음
```
//1번 케이스
println("반짝 반짝 작은 박쥐 \n" +
"어디 있는지 모르겠다. \n" +
"세상 꼭대기로 나네 \n" +
"하늘 속 쟁반 같구나 \n" +
"반짝반짝 작은 박쥐 \n" +
"어디 있는지 모르겠다! \n" +)
```
- 위 방법은 솔직히 귀찮다
- 아래 방법처럼 삼중따옴표로 문자열 리터럴을 정의할 수 있다.
```
//1번 케이스
println("""반짝 반짝 작은 박쥐
어디 있는지 모르겠다.
세상 꼭대기로 나네
하늘 속 쟁반 같구나
반짝반짝 작은 박쥐
어디 있는지 모르겠다!"""
)
```
- 같은 방법을 훨씬 더 꺠끗한 방법으로 해냈다. 하지만 위의 예제를 실행시켜보면 시의 들여쓰기가 예상과 다르게 출력되는 것을 알 수 있다.
- 여러 줄 문자열이 탭과 같은 공백 문자를 보존하기 때문에 생기는 현상임
- 제대로 출력하려면 다음과 같이 trimIndent() 함수를 호출해야함
```
println("""
반짝반짝 작은 박쥐
어디 있는지 모르겠다!
""".trimIndent())
```
- 여러 줄 문자열에는 또 다른 쓸모가 있다.
- 여러 줄 문자열 안에 있는 따옴표는 이스케이프 하지 않아도 된다는 점
- 다음 예제를 보자
```
println("소설 \" 이상한 나라의 앨리스 \ "에서 발췌")
```
- 일반 문자열에서는 이처럼 텍스트에 포함된 따옴표를 역슬래시로 이스케이프 해야 한다.

## 반복문
- 이제 또 다른 대표적 제어 구문인 반복문을 살펴보자
- 개발자라면 반복문이 굉장히 익숙할 것
- 반복문 없이 같은 코드 블록을 여러번 실행하기란 꽤 어려운 일임(하지만 이후의 장들에서 반복문을 사용하지 않고도 코드 블록을 반복하는 법을 배울 것)

### for-in 반복문
- 코틀린에서 가장 유용한 반복문은 아마도 for-in 반복문일 것이다.
- 이 반복문을 사용하면 문자열이나 자료 구조 등 반복자를 갖고 있는 모든 것에 대해 반복을 수행할 수 있다.
- 반복자에 대해서는 4장에서 배울 것
- 지금은 간단한 문자열에 반복문을 적용하는 것을 살펴보자
```
for (c in "Word"){
    println(c)
}
```
- 이 코드를 실행하면 다음과 같이 출력됨
```
>W
>o
>r
>d
```
- for-in 반복문은 지금까지 살펴본 모든 종류의 자료구조에서 사용할 수 있음
- 리스트 반복문 적용코드를 살펴보자
```
val jokers = listOf("히스 레저", "호아킨 피닉스", "잭 니콜슨")
for (j in jokers){
    println(j)
}
> 히스 레저
> 호아킨 피닉스
> 잭 니콜슨
```
- 이 반복문은 쓸모가 매우 많기 때문에 책에서 반복적으로 등장할 것

### for 반복문
- 어떤 언어에서는 for-in 반복문이 별개의 문법임
- 그러나 코틀린에서 for 반복문은 그저 범위 range에 적용한 for-in 반복문일 뿐
- 이해를 돕기 위해 한 자릿수를 모두 출력하는 for 반복문 예제를 보자

```
for (i in 0..9){
    println(i)
}
```
- 자바의 반복문과 다르게 생겼고 오히려 파이썬이 떠오를 것임
- 0과 9사이의 온점 2개를 범위 연산자라고 부름
- 위의 코드를 실행해 보면 범위가 상한을 포함한다는 것을 알 수 있을 것
- 즉 9를 포함한 모든 수가 출력됨
```
for(int i = 0; i<=9; i++)
```
- 만약 상한이 범위에 포함되지 않기를 원한다면 until 함수를 사용하자.
```
for(i in 0 until 10) {
    println("for" until $1) // 위의 코드와 똑같이 출력됨
}
```
- 역순으로 출력하고 싶다면 downTo 함수를 사용한다.
```
for (i in 9 downTo 0) {
    println("for downTo $1") // 9,8,7..
}
```
- 계속 until이나 downTo를 함수라고 부르는 것이 혼란스러울 수 있다.
- 함수보다 연산자처럼 보이기 때문이다.
- 이것은 중위 함수라고 하는 코틀린의 재미있는 기느응로 더 자세히 다룰 것임

### while 반복문
- 반복문은 다른 언어와 동일하기 때문에 간단히 살펴본다.
```
var x = 0
while (x < 10) {
    x++
    println("while $x")
}
```
- 이 코드는 1부터 10까지 수를 출력할 것이다. 여기서 변수x는 반드시 var를 이용해 선언해야 한다는 점에서 주의
- 자주 사용하지는 않지만, do while 반복문도 존재함

```
var x= 5
do {
    println("do while $x")
    x--
}while (x>0)
```
- 아마 코틀린에서 while 반복문을 사용할 일은 없을 것
- do-while 반복문은 더욱 그렇다.
- 이어지는 장들에서 같은일을 "코틀린 답게" 하는 방법을 살펴볼 것

## 클래스와 상속
- 코틀린은 다중 패러다임 언어이긴 하나 자바의 친척뻘임은 부인하 수 없음
- 자바는 클래스에 기반한 언어기에 코틀린에도 당연한 기능이다.
- 클래스, 인터페이스, 추상클래스, 데이터 클래스를 선언하는 문법을 다룰 것

### 클래스
- 클래스란 데이터와 메서드를 한데 모아놓은 것
- 클래스를 선언할 때 자바와 똑같이 class 키워드를 사용함
- 컴퓨터 게임을 만든다고 생각할 때 플레이어를 나타내는 클래스는 다음과 같이 정의할 수 있음
```
class Player{

}
```
- 클래스를 인스턴트화 하는 방법도 간단함
```
val player = Player()
```
- 코틀린에서는 new 키워드를 사용하지 않는다.
- 코틀린 컴파일러는 클래스 이름 뒤에 괄호() 가 있으면 새로운 인스턴스를 생성한느 것으로 인식함
- 위의 예제처럼 클래스 본문이 없는 경우에는 중괄호를 생략할 수 있음
```
class Player // 유효한 클래스 선언
```
- 아무런 함수나 속성이 없는 클래스는 특별히 쓸모 있지는 않지만, 4장에서 왜 이런 문법이 존재하며 어떻게 코틀린의 다른 기능과 어우러지는제 살펴볼 것

### 주 생성자
- 플레이어를 생성할 때 이름을 지정할 수 있음 좋을 것임
- 이를 위해 Player 클래스에 주 생성자를 추가해보자
```
class Player(name : String)
```
- 이제 다음과 같은 선언은 불가능함
```
val player = Player()
```
- 다음과 같이 새로운 플레이어 객체를 만들 때마다 이름을 넣어 줘야 함
```
val player = Player("Roland")
```
- 생성자를 잠시 뒤에 살펴보고, 지금은 속성에 대해 알아보자

### 속성
- 자바를 사용하다 보면 접근자(getter)와 설정자(setter)의 개념이 익숙해진다.
- 플레이어를 나타내는 클래스를 자바 스타일로 작성한 코틀린 코드는 아래와 같다.
```
class Player(name :String){
    private var name = String = name

    fun getName(): String {
        return name
    }

    fun setName(name : String) {
        this.name = name;
    }
}
```
- 플레이어의 이름을 알아내기 위해서는 getName() 메서드를 호출함.
- 플레이어의 이름을 바꾸려면 setName() 메서드를 호출함
- 매우 단순하긴 하지만 너무 많은 코드를 작성해야 함
- 코틀린의 this 키워드가 처음으로 등장했으니 짧게 뜻을 설명하고 넘어가면
- 다른 언어처럼 this는 해당 클래스의 현재 객체를 가리키는 참조를 담고 있다.
- 이 예제에서는 player 클래스의 인스턴스를 가리킴
- 그냥 클래스를 다음과 같이 작성하면 안되나
```
class Player {
    var name : String = ""
}
```
- 언뜻 괜찮은 방법같아 보이며 당연히 코드 양은 훨씬 줄었다.
- 플레이어 이름도 player.name 으로 간단히 알아낼 수 있다.
- 플레이어의 이름을 바꾸는 것도 훨씬 직관적임. player.name = "Alex"와 같이 하면됨
- 하지만 이런식으로 하면 객체를 통제할 수 없게됨
- 가령 Player를 불변으로 만들 수 없다.
- 모두에게 플레이어릐 이름을 읽을 권한을 주면, 동시에 이름을 수정할 권한까지갖게 됨
- 나중에 코드를 수정할 계획이라면 이건 심각한 문제가 될 수 있다.
- 이처럼 설정자를 사용할 때 통제할 수 있던 부분이 공개 필드를 사용할 떄 통제를 벗어나게 됨