- 코틀린 디자인패턴 책

## 1장 코틀린 시작하기

### 명명규칙
- 우선 코틀린은 .kt 로 끝나는 소스이다
- 파일명은 클래스명과 동일하게 짓는다 패턴은 그뒤에
- 파일명에는 카멜 케이스를 사용한다(책에서 나온 내용임)
  * 카멜케이스란? : 맨 앞 단어기준문자제외 그이후 단어단위 앞쪽에 대문자를 사용하여 이름을 읽기 쉽게 지음
- 메인은 대부분 Main.kt 임

## 패키지
- 비슷한 목적 또는 도메인을 공유하는 파일과 클래스의 묶음
- 자바랑 비슷하게 아래와 같이 키워드를 시용
```
//package 대단위.중단위.소단위
```
- 자바와 동일하게 간다고 생각하면 됨
- Main.kt 에서는 패키지를 선언하지 않아도 됨

### 주석
// 한줄
/**/ 여러줄

### Hello Kotlin
```
//국룰 소스코드

fun main(){ // 코틀린은 fun 키워드로 함수 사용
	println(“hello kotlin”) // 자바처럼 앞 패키지 선언은 안해도 된다
}
```
### 감싸는 클래스가 없음
- 코틀린에는 패키지 수준 함수라는 개념이 있음
- 클래스 속성에 접근할 필요가 없는 함수라면 굳이 클래스로 감싸지 않아도 된다는 것
- 책의 뒷부분에서 패키지 수준 함수에 대해 더 자세히 살펴볼 것

### 명령줄 인수가 없음
```
public static void main(String [] args) {…} // 명령줄 인수 선언코드
```

### static 키워드가 없음
- 어떤 언어에서 클래스를 인스턴스화 하지 않고도 실행할 수 있는 함수를 나타내기 위해 static을 사용
- 코틀린에서는 상태를 갖지 않는 함수는 클래스 밖에 두면 됨
- 그래서 코틀린에는 static 키워드가 없음

### 더 간결한 출력함수
- println() //ㅈㄱㄴ

### 세미 콜론이 없음
- 자바나 다른 언어에서는 세미콜론 사용하는 빈도가 많다
코틀린은 세미콜론 없음

## 타입 이해하기

### 기본 타입
- 어떤 언어에서는 원시타입 (primitive type) 객체로 구분
- 코틀린에서는 그런 구분 자체가 없다 모든 타입에서 동등함
- 대부분의 타입은 자바와 비슷
- 예외로 친다면 자바의 Integer는 코틀린에서 Int임
- 자바의 Void 는 코틀린에서 Unit임

#### 예시
- 수
  - Int, Long, Double
- 문자열
  - String
- 부울
  - Boolean
- 문자
  - Char

### 타입추론
```
var greeting = “hello Kotlin”
Println
```
- 이 다음 코드에서 오류를 발생시킬 수 있다
```
greeting = 1
// 코틀린에서는 자동으로 타입 추론을 하므로 자료형 선언이 되어있지 않다 하더라도 숫자형으로 맘대로 바꿀 수 없음
```
- 오류가 발생하는 이유는 변수의 타입을 딱 한번만 정의하기 때문
- 만약 변수를 명시적으로 선언하려고 한다면 아래와 같이 선언한다.
```
var greeting : String = “hello Kotlin”
```

### 값
- 자바에서는 변수를 final로 선언할 수 있음
- sfinal 변수는 딱 한번만 할당되고 이 변수에 대한 참조는 사실상 불변(immutable)
```
final String s = “hi”;
s = “Bye”;
```
- 코틀린에서 이 방법을 한번에 바꿔버리는 방법이 있다
- val을 사용하는 방법
- var와 val의 차이라고 할 수 있으며 val은 불변된 값 지정이 가능하다
```
val greeting = “Hi”//final 과 같은 역할을 한다.
greeting = “Bye”//불가능
```
- 변수보다 값을 더 사용하는 것이 바람직한데, 불변 데이터가 값을 추적하기 알맞기 때문


### 비교와 동등성
- 자바에서는 객체끼리 비교시 == 연산자를 사용하면 원하는 결과를 얻지 못한다는 것을 익히 알고 있을것
- == 연산자는 두 객체가 동등한지 비교하는 대신 두 포인터가 같은 객체를 바라보고 있는지 비교하기때문
- 대신 자바 객체비교에 equals()를 사용하고, ==는 원시타입 변수끼리 비교할때만 사용함
- 코틀린 또한 ==연산자를 equals()로 해석한다
- 참조 동등성을 확인하려면 === 을 사용
- 그러나 기본타입 중에는 참조 동등성 비교가 불가능한 타입도 있음.

### 함수선언
- 자바에서 모든 메서드는 클래스나 인터페이스 안에 있어야 함
- 클래스나 인터페이스의 정보를 전혀 사용하지 않더라도 그렇다
- 코틀린에서는 클래스 바깥에도 함수를 선언할 수 있다. main()함수가 그런 케이스임
- 함수를 선언할 때 fun 키워드를 사용한다.
- 인수의 경우 인수 앞이 아니라 뒤에 온다.
```
fun greet(greeting: String){
	println(greeting)
}
```
- 결과를 반환해야 한다면 반환형은 함수 선언 뒷부분에 기술
```
fun getGreeting():String{
	return “Hello, Kotlin!”
}
```
```
// 아래 코드도 직접 실행해보자
fun main(){
	greet(getGreeting())
}
```
- 함수가 아무것도 반환하지 않는다면 반환형은 아예 생략할 수 있다
- 즉 void 타입(코틀린상에서 Unit)으로 선언할 필요가 없음
- 함수가 식 하나로 표현될 만큼 짧다면 (위의 getGreeting()함수같이) 반환형과 중괄호를 지우고 다음과 같이 더 짧게 쓸 수 있다
```
fun getGreeting() = “hello, Kotlin”
```
- 이 때 코틀린 컴파일러는 함수가 String 타입을 반환하는 것을 추론할 것
- 어떤 스크립트 언어에서는 함수 선언 순서가 중요하나, 코틀린에서는 아님
- 가령 예제 코드의 main 함수는 시야에 있는 모든 함수를 호출할 수 있음
- Main 함수는 시야의 모든 함수를 호출 할 수 있음
- main 함수보다 뒤에 선언됐더라도 호출할 수 있음

### null 안전성
- nullpointException 이 발생되는 주 원인은 어떤 객체든 null일 수 있기 대문에 발생된다
- 이러한 문제를 해결하기 위해 자바 8에서는 새로운 클래스인Optional 을 사용하여 값이 없을 수 있다는 것을 표현할 수 있다.
```
var optional = Optional.of(“null 이 아닌 문자열”)
if(optional.isPresent()){
	System.out.println(optional.get().length());
}
```
- 그러나 인수로 받는 함수도 null를 전달할 수 있고 그렇게되면 런타임 오류가 발생된다.
```
void printLength(Optional<String> optional) {
	if(optional.isPresent()){
		System.out.println(optional.get().length());
	}
}
PrintLength(null);
```
- 코틀린의 경우 컴파일 시 null 검사를 수행함
```
val s: String = null // 컴파일 불가
```
- 아래 코틀린으로 작성된 PrintLength() 함수가 있다
```
fun printLength(s: String){
	println(s.length)
}
```
- 위 함수에 Null 을 전달하면 컴파일이 되지 않음
```
printLength(null)
// “Null cannot be a value of a non-null type String” 오류 발생
```
- 만약에 null을 받고 싶다면
```
fun printLength(stringOrNull : String?){…}
```
- 위 코드와 같이 자료형 뒤에 ?를 입력하여 null 이 들어갈 수 있음을 명시함

## 코틀린 자료구조 복습
- 이라고 하기엔 첨본 내용도 많음

### 리스트
- 같은 타입을 갖는 원소의 순서 있는 집합을 이야기함
- 코틀린에서는 list 함수를 사용해서 리스트를 선언함
```
val hobbits = listOf(“프로도”, “샘”, “피핀”, “메리”)
```
- 리스트의 타입을 선언하지 않았다는 점에 주목
- 코틀린에서는 변수를 초기화할 때와 마찬가지로 집합 자료 구조를 만들 때도 타입 추론이 가능하기 때문
- 리스트의 다입을 명시하고 싶다면 함수의 인수 정의와 비슷한 방법으로 사용할 수 있음
```
val hobbits: List<String> = listOf(“프로도”, “샘” , “피핀” , “메리”)
```
- 특정 인덱스로 리스트 원소에 접근할 때는 대괄호를 사용
```
println(hobbits[1])
//코드 실행 시 아래와 같이 출력됨
>샘
```

### 세트
- 세트는 중복없는 원소의 집합
- 세트에서 원솔르 찾는 것은 리스트에서보더 훨씬 빠름
- 리스트와 달리 인덱스에서의 접근은 불가능하다
- 대충 똑같은거 때려박아도 중복이 안되게 출력됨

```
val footballChampions = setOf(“프랑스”, “독일”,“스페인”,“이탈리아”,“브라질”,“프랑스”,“브라질”,“독일”)
println(footballChampions) //[프랑스, 독일, 스페인, 이탈리아. 브라질]
```
- 세트에 어떤 원소가 있는지는 in 함수를 사용함
```
println(입력값 in setOf 변수)
```
- 일반적으로 세트는 원소의 순서를 보장하지 않음
- 그러나 현재 setOf() 함수는 LinkedHashSet을 반환하도록 구현되어있는데, 이 클래스는 원소가 추가된 순서를 보존한다.
- 즉 위의 예제에서 프랑스는 맨 먼저 출력되는데, 이는 입력 순서상 가장 앞에 있었던 까닭임

### 맵
- 맵은 키의 유일성이 보장되는 키-값 쌍의 집합
- 두 원소의 쌍을 만드는 키워드는 to
- 사실 to는 진짜 키워드는 아니고 특별한 함수임
```
val movieBatmans = mapOf(
	“배트맨 리턴즈” to “마이클 키튼”,
	“배트맨 포에버” to “발 킬머”
	“배트맨과 로빈” to “조지 클루니”
)
println(movieBatmans)
```
- 키를 이용해 값을 조회하려면. 대괄호 안에 키를 넣으면 됨
```
println(movieBatmans[“배트맨 리턴즈”])
```
- 부재를 검사하는 기능도 있음
```
println(“배트맨 비긴즈” !in movieBatman)
> true //이런식으로 출력
```

### 가변성
- 여태 소개한 자료구조는 불변임 더 정확히는 읽기 전용임
- listOf() 함수로 만든 리스트에는 새로운 원소를 추가하는 메서드가 없음.
- 원소의 값을 바꿀 수도 없음
- 불변 자료구조는 동시성 코드를 작성할떄 매우 도움이 됨
- 하지만 수정 가능한 자료구조가 필요할 때도 있는데 그러럐ㄸ는 집합 자료 구조를 만드는 함수의 가변 버전을 사용할 수 있음
```
val editableHobbits = mutableListOf("프로도", "샘", "피핀", "메리")
editableHobbits.add("빌보")
```
- 수정 가능한 집합에는 add()같은 함수가 있어서 변경이 가능함. 즉 가변적이다.

### 집합 자료 구조의 다른 구현체
- 이전에 JVM을 사용해 본적이 있다면 세트와 맵에 다른 구현체가 있다는 것을 알 것
- 예를들어 TreeMap은 키를 정렬된 상태로 저장함
```
import java.util.*
//키로 정렬되는 가변 맵

val treeMap = java.util.TreeMap(
    mapOf("첫째돼지" to "지푸라기 집",
        "둘째 돼지" to "나무 집",
        "셋쨰 돼지" to "벽돌 집"
    )
)
println(treeMap.keys)
```
- 다음과 같이 출력될 것
```
> 둘째 돼지, 셋째 돼지, 첫째 돼지
```
- 알고리즘에 써먹어라
- 가나다 순으로 알아서 정렬됨

### 배열
- 이 절에서 꼭 짚고 넘어가야 할 자료구조래
- 자바에서 배열은 대괄호를 사용하는 특별한 문법을 갖고있음
- 코틀린에서는 대괄호 뭐시깽이 말고 컬렉션을 사용함(제네릭 함수)
#### 아래와 같이 선언함
```
val musketeers: Array<String> = arrayOf("아토스", "포르토스", "아라미스")
```
- 코틀린 코드에 처음으로 꺾쇠 괄호가 등장함 
- 자바나 타입스크립트에서 처럼 꺾쇠 괄호가 들어가는 타입을 타입인수라고 함
- 여기선 배열에 문자열이 들어있다는 것을 나타냄
- 4장 제네릭 설명때 다시 이야기함
#### 이미 만들어진 집합 자료 구조를 배열로 변환하고자 한다면 toTypedArray함수를 이용한다.
```
listOf(1,2,3,5).toTypedArray()
``` 
- 기능적인 측면에서 코틀린 배열은 리스트와 매우 유사함
- 예를 들어 코틀린 배열의 원소 갯수를 구하려면 다른 집ㅎ바 구조와 마찬가지로 size속성을 사용
- 언제 배열을 사용해야하나 먼저 main 함수에서 인수를 받을 때
- 앞에 예제에서는 인수 없는 main함수만 봤지만 명령줄 인수를 전달하는 경우도 있음
#### 다음 예제는 명령줄 인수를 받아서 쉼표로 연결한 뒤 출력하는 main함수임
```
fun main(args: Array<String>){
    println(args.joinToString(", "))
}
```
- 배열을 인수로 받는 자바 함수를 호출하거나 varargs 문법을 사용하는 경웽도 배열이 필요함
- 이런 내용은 3장에서 다룸

## 제어흐름
- 프로그램을 작성할 때 제어흐름은 빠질 수 없음, 잘 알고있다시피 if와 when을 주로 사용함

### IF문
```
public String getUnixSocketPolling(boolean isBsd){
    if(isBsd){
        return "Kqueue";
    }else{
        return "epoll";
    }
}
```
- 대충 자바라 소스가 간결하지 못하단 소리
- 코틀린에서는 if가 식이기 때문에 값을 반환할 수 있다.
- 위의 함수를 코틀린으로는 다음과 같이 작성할 수 있음
```
fun getUnixSocketPolling(isBsd: Boolean): String{
    return if (isBsd){
        "kqueue"
    }else{
        "epoll"
    }
}
```
- 더 짧게 작성하면 아래와 같다
```
fun getUnixSocketPolling (isBsd: Boolean): String = if (isBsd) "kqueue" else "epoll"
```
- if가 식이라는 사실 덕분에 지역 변수를 선언하지 않아도 됨
- 여기서도 단일식 함수와 타입 추론을 사용하고 있음
- if가 String타입의 값을 반환하고 있다는 것이 중요한 부분임
- 여러개의 return문을 사용할 필요도 없고, 가변 변수를 사용할 필요가 없다 

## When 조건식
- if문에 더 많은 조건을 넣고 싶다면 어떻게 해야할까
- 자바에서는 switch문을 사용한다. 코틀린에서는 when을 사용함
- when은 코틀린의 다른 기능과 결합해서 사용할 때 훨씬 강력함. 슈퍼히어로의 이름을 넣으면 그의 숙적이 누구인지 알려주는 메소드를 알아보자
```
fun archenemy(heroName : String) = when(heroName){
    "배트맨" -> "조커"
    "슈퍼맨" -> "렉스 루터"
    "스파이더맨" -> "그린고블린"
    else -> "ㅈㅅ 모름"
}
//키포인트는 mapOf때처럼 ,로 구분자를 주는 것이 아닌 그대로 -> 당 하나로 ,를 입력하지 않ㄴ는다 까먹지 말도록
```