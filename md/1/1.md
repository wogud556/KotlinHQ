- 코틀린 디자인패턴 책

## 1장 코틀린 시작하기

### 명명규칙
- 우선 코틀린은 .kt 로 끝나는 소스이다
- 파일명은 클래스명과 동일하게 짓는다 패턴은 그뒤에
- 파일명에는 카멜 케이스를 사용한다(책에서 나온 내용임)
  * 카멜케이스란? : 맨 앞 단어기준문자제외 그이후 단어단위 앞쪽에 대문자를 사용하여 이름을 읽기 쉽게 지음
- 메인은 대부분 Main.kt 임

## 패키지
- 비슷한 목적 또는 도메인을 공유하는 파일과 클래스의 묶음
- 자바랑 비슷하게 아래와 같이 키워드를 시용
```
//package 대단위.중단위.소단위
```
- 자바와 동일하게 간다고 생각하면 됨
- Main.kt 에서는 패키지를 선언하지 않아도 됨

### 주석
// 한줄
/**/ 여러줄

### Hello Kotlin
```
//국룰 소스코드

fun main(){ // 코틀린은 fun 키워드로 함수 사용
	println(“hello kotlin”) // 자바처럼 앞 패키지 선언은 안해도 된다
}
```
### 감싸는 클래스가 없음
- 코틀린에는 패키지 수준 함수라는 개념이 있음
- 클래스 속성에 접근할 필요가 없는 함수라면 굳이 클래스로 감싸지 않아도 된다는 것
- 책의 뒷부분에서 패키지 수준 함수에 대해 더 자세히 살펴볼 것

### 명령줄 인수가 없음
```
public static void main(String [] args) {…} // 명령줄 인수 선언코드
```

### static 키워드가 없음
- 어떤 언어에서 클래스를 인스턴스화 하지 않고도 실행할 수 있는 함수를 나타내기 위해 static을 사용
- 코틀린에서는 상태를 갖지 않는 함수는 클래스 밖에 두면 됨
- 그래서 코틀린에는 static 키워드가 없음

### 더 간결한 출력함수
- println() //ㅈㄱㄴ

### 세미 콜론이 없음
- 자바나 다른 언어에서는 세미콜론 사용하는 빈도가 많다
코틀린은 세미콜론 없음

## 타입 이해하기

### 기본 타입
- 어떤 언어에서는 원시타입 (primitive type) 객체로 구분
- 코틀린에서는 그런 구분 자체가 없다 모든 타입에서 동등함
- 대부분의 타입은 자바와 비슷
- 예외로 친다면 자바의 Integer는 코틀린에서 Int임
- 자바의 Void 는 코틀린에서 Unit임

#### 예시
- 수
  - Int, Long, Double
- 문자열
  - String
- 부울
  - Boolean
- 문자
  - Char

### 타입추론
```
var greeting = “hello Kotlin”
Println
```
- 이 다음 코드에서 오류를 발생시킬 수 있다
```
greeting = 1
// 코틀린에서는 자동으로 타입 추론을 하므로 자료형 선언이 되어있지 않다 하더라도 숫자형으로 맘대로 바꿀 수 없음
```
- 오류가 발생하는 이유는 변수의 타입을 딱 한번만 정의하기 때문
- 만약 변수를 명시적으로 선언하려고 한다면 아래와 같이 선언한다.
```
var greeting : String = “hello Kotlin”
```

### 값
- 자바에서는 변수를 final로 선언할 수 있음
- sfinal 변수는 딱 한번만 할당되고 이 변수에 대한 참조는 사실상 불변(immutable)
```
final String s = “hi”;
s = “Bye”;
```
- 코틀린에서 이 방법을 한번에 바꿔버리는 방법이 있다
- val을 사용하는 방법
- var와 val의 차이라고 할 수 있으며 val은 불변된 값 지정이 가능하다
```
val greeting = “Hi”//final 과 같은 역할을 한다.
greeting = “Bye”//불가능
```
- 변수보다 값을 더 사용하는 것이 바람직한데, 불변 데이터가 값을 추적하기 알맞기 때문


### 비교와 동등성
- 자바에서는 객체끼리 비교시 == 연산자를 사용하면 원하는 결과를 얻지 못한다는 것을 익히 알고 있을것
- == 연산자는 두 객체가 동등한지 비교하는 대신 두 포인터가 같은 객체를 바라보고 있는지 비교하기때문
- 대신 자바 객체비교에 equals()를 사용하고, ==는 원시타입 변수끼리 비교할때만 사용함
- 코틀린 또한 ==연산자를 equals()로 해석한다
- 참조 동등성을 확인하려면 === 을 사용
- 그러나 기본타입 중에는 참조 동등성 비교가 불가능한 타입도 있음.

### 함수선언
- 자바에서 모든 메서드는 클래스나 인터페이스 안에 있어야 함
- 클래스나 인터페이스의 정보를 전혀 사용하지 않더라도 그렇다
- 코틀린에서는 클래스 바깥에도 함수를 선언할 수 있다. main()함수가 그런 케이스임
- 함수를 선언할 때 fun 키워드를 사용한다.
- 인수의 경우 인수 앞이 아니라 뒤에 온다.
```
fun greet(greeting: String){
	println(greeting)
}
```
- 결과를 반환해야 한다면 반환형은 함수 선언 뒷부분에 기술
```
fun getGreeting():String{
	return “Hello, Kotlin!”
}
```
```
// 아래 코드도 직접 실행해보자
fun main(){
	greet(getGreeting())
}
```
- 함수가 아무것도 반환하지 않는다면 반환형은 아예 생략할 수 있다
- 즉 void 타입(코틀린상에서 Unit)으로 선언할 필요가 없음
- 함수가 식 하나로 표현될 만큼 짧다면 (위의 getGreeting()함수같이) 반환형과 중괄호를 지우고 다음과 같이 더 짧게 쓸 수 있다
```
fun getGreeting() = “hello, Kotlin”
```
- 이 때 코틀린 컴파일러는 함수가 String 타입을 반환하는 것을 추론할 것
- 어떤 스크립트 언어에서는 함수 선언 순서가 중요하나, 코틀린에서는 아님
- 가령 예제 코드의 main 함수는 시야에 있는 모든 함수를 호출할 수 있음
- Main 함수는 시야의 모든 함수를 호출 할 수 있음
- main 함수보다 뒤에 선언됐더라도 호출할 수 있음

### null 안전성
- nullpointException 이 발생되는 주 원인은 어떤 객체든 null일 수 있기 대문에 발생된다
- 이러한 문제를 해결하기 위해 자바 8에서는 새로운 클래스인Optional 을 사용하여 값이 없을 수 있다는 것을 표현할 수 있다.
```
var optional = Optional.of(“null 이 아닌 문자열”)
if(optional.isPresent()){
	System.out.println(optional.get().length());
}
```
- 그러나 인수로 받는 함수도 null를 전달할 수 있고 그렇게되면 런타임 오류가 발생된다.
```
void printLength(Optional<String> optional) {
	if(optional.isPresent()){
		System.out.println(optional.get().length());
	}
}
PrintLength(null);
```
- 코틀린의 경우 컴파일 시 null 검사를 수행함
```
val s: String = null // 컴파일 불가
```
- 아래 코틀린으로 작성된 PrintLength() 함수가 있다
```
fun printLength(s: String){
	println(s.length)
}
```
- 위 함수에 Null 을 전달하면 컴파일이 되지 않음
```
printLength(null)
// “Null cannot be a value of a non-null type String” 오류 발생
```
- 만약에 null을 받고 싶다면
```
fun printLength(stringOrNull : String?){…}
```
- 위 코드와 같이 자료형 뒤에 ?를 입력하여 null 이 들어갈 수 있음을 명시함

## 코틀린 자료구조 복습
- 이라고 하기엔 첨본 내용도 많음

### 리스트
- 같은 타입을 갖는 원소의 순서 있는 집합을 이야기함
- 코틀린에서는 list 함수를 사용해서 리스트를 선언함
```
val hobbits = listOf(“프로도”, “샘”, “피핀”, “메리”)
```
- 리스트의 타입을 선언하지 않았다는 점에 주목
- 코틀린에서는 변수를 초기화할 때와 마찬가지로 집합 자료 구조를 만들 때도 타입 추론이 가능하기 때문
- 리스트의 다입을 명시하고 싶다면 함수의 인수 정의와 비슷한 방법으로 사용할 수 있음
```
val hobbits: List<String> = listOf(“프로도”, “샘” , “피핀” , “메리”)
```
- 특정 인덱스로 리스트 원소에 접근할 때는 대괄호를 사용
```
println(hobbits[1])
//코드 실행 시 아래와 같이 출력됨
>샘
```

### 세트
- 세트는 중복없는 원소의 집합
- 세트에서 원솔르 찾는 것은 리스트에서보더 훨씬 빠름
- 리스트와 달리 인덱스에서의 접근은 불가능하다
- 대충 똑같은거 때려박아도 중복이 안되게 출력됨

```
val footballChampions = setOf(“프랑스”, “독일”,“스페인”,“이탈리아”,“브라질”,“프랑스”,“브라질”,“독일”)
println(footballChampions) //[프랑스, 독일, 스페인, 이탈리아. 브라질]
```
- 세트에 어떤 원소가 있는지는 in 함수를 사용함
```
println(입력값 in setOf 변수)
```
- 일반적으로 세트는 원소의 순서를 보장하지 않음
- 그러나 현재 setOf() 함수는 LinkedHashSet을 반환하도록 구현되어있는데, 이 클래스는 원소가 추가된 순서를 보존한다.
- 즉 위의 예제에서 프랑스는 맨 먼저 출력되는데, 이는 입력 순서상 가장 앞에 있었던 까닭임

### 맵
- 맵은 키의 유일성이 보장되는 키-값 쌍의 집합
- 두 원소의 쌍을 만드는 키워드는 to
- 사실 to는 진짜 키워드는 아니고 특별한 함수임
```
val movieBatmans = mapOf(
	“배트맨 리턴즈” to “마이클 키튼”,
	“배트맨 포에버” to “발 킬머”
	“배트맨과 로빈” to “조지 클루니”
)
println(movieBatmans)
```
- 키를 이용해 값을 조회하려면. 대괄호 안에 키를 넣으면 됨
```
println(movieBatmans[“배트맨 리턴즈”])
```
- 부재를 검사하는 기능도 있음
```
println(“배트맨 비긴즈” !in movieBatman)
> true //이런식으로 출력
```

### 가변성
- 여태 소개한 자료구조는 불변임 더 정확히는 읽기 전용임
- listOf() 함수로 만든 리스트에는 새로운 원소를 추가하는 메서드가 없음.
- 원소의 값을 바꿀 수도 없음
- 불변 자료구조는 동시성 코드를 작성할떄 매우 도움이 됨
- 하지만 수정 가능한 자료구조가 필요할 때도 있는데 그러럐ㄸ는 집합 자료 구조를 만드는 함수의 가변 버전을 사용할 수 있음
```
val editableHobbits = mutableListOf("프로도", "샘", "피핀", "메리")
editableHobbits.add("빌보")
```
- 수정 가능한 집합에는 add()같은 함수가 있어서 변경이 가능함. 즉 가변적이다.

### 집합 자료 구조의 다른 구현체
- 이전에 JVM을 사용해 본적이 있다면 세트와 맵에 다른 구현체가 있다는 것을 알 것
- 예를들어 TreeMap은 키를 정렬된 상태로 저장함
```
import java.util.*
//키로 정렬되는 가변 맵

val treeMap = java.util.TreeMap(
    mapOf("첫째돼지" to "지푸라기 집",
        "둘째 돼지" to "나무 집",
        "셋쨰 돼지" to "벽돌 집"
    )
)
println(treeMap.keys)
```
- 다음과 같이 출력될 것
```
> 둘째 돼지, 셋째 돼지, 첫째 돼지
```
- 알고리즘에 써먹어라
- 가나다 순으로 알아서 정렬됨

### 배열
- 이 절에서 꼭 짚고 넘어가야 할 자료구조래
- 자바에서 배열은 대괄호를 사용하는 특별한 문법을 갖고있음
- 코틀린에서는 대괄호 뭐시깽이 말고 컬렉션을 사용함(제네릭 함수)
#### 아래와 같이 선언함
```
val musketeers: Array<String> = arrayOf("아토스", "포르토스", "아라미스")
```
- 코틀린 코드에 처음으로 꺾쇠 괄호가 등장함 
- 자바나 타입스크립트에서 처럼 꺾쇠 괄호가 들어가는 타입을 타입인수라고 함
- 여기선 배열에 문자열이 들어있다는 것을 나타냄
- 4장 제네릭 설명때 다시 이야기함
#### 이미 만들어진 집합 자료 구조를 배열로 변환하고자 한다면 toTypedArray함수를 이용한다.
```
listOf(1,2,3,5).toTypedArray()
``` 
- 기능적인 측면에서 코틀린 배열은 리스트와 매우 유사함
- 예를 들어 코틀린 배열의 원소 갯수를 구하려면 다른 집ㅎ바 구조와 마찬가지로 size속성을 사용
- 언제 배열을 사용해야하나 먼저 main 함수에서 인수를 받을 때
- 앞에 예제에서는 인수 없는 main함수만 봤지만 명령줄 인수를 전달하는 경우도 있음
#### 다음 예제는 명령줄 인수를 받아서 쉼표로 연결한 뒤 출력하는 main함수임
```
fun main(args: Array<String>){
    println(args.joinToString(", "))
}
```
- 배열을 인수로 받는 자바 함수를 호출하거나 varargs 문법을 사용하는 경웽도 배열이 필요함
- 이런 내용은 3장에서 다룸

## 제어흐름
- 프로그램을 작성할 때 제어흐름은 빠질 수 없음, 잘 알고있다시피 if와 when을 주로 사용함

### IF문
```
public String getUnixSocketPolling(boolean isBsd){
    if(isBsd){
        return "Kqueue";
    }else{
        return "epoll";
    }
}
```
- 대충 자바라 소스가 간결하지 못하단 소리
- 코틀린에서는 if가 식이기 때문에 값을 반환할 수 있다.
- 위의 함수를 코틀린으로는 다음과 같이 작성할 수 있음
```
fun getUnixSocketPolling(isBsd: Boolean): String{
    return if (isBsd){
        "kqueue"
    }else{
        "epoll"
    }
}
```
- 더 짧게 작성하면 아래와 같다
```
fun getUnixSocketPolling (isBsd: Boolean): String = if (isBsd) "kqueue" else "epoll"
```
- if가 식이라는 사실 덕분에 지역 변수를 선언하지 않아도 됨
- 여기서도 단일식 함수와 타입 추론을 사용하고 있음
- if가 String타입의 값을 반환하고 있다는 것이 중요한 부분임
- 여러개의 return문을 사용할 필요도 없고, 가변 변수를 사용할 필요가 없다 

## When 조건식
- if문에 더 많은 조건을 넣고 싶다면 어떻게 해야할까
- 자바에서는 switch문을 사용한다. 코틀린에서는 when을 사용함
- when은 코틀린의 다른 기능과 결합해서 사용할 때 훨씬 강력함. 슈퍼히어로의 이름을 넣으면 그의 숙적이 누구인지 알려주는 메소드를 알아보자
```
fun archenemy(heroName : String) = when(heroName){
    "배트맨" -> "조커"
    "슈퍼맨" -> "렉스 루터"
    "스파이더맨" -> "그린고블린"
    else -> "ㅈㅅ 모름"
}
//키포인트는 mapOf때처럼 ,로 구분자를 주는 것이 아닌 그대로 -> 당 하나로 ,를 입력하지 않ㄴ는다 까먹지 말도록
```
- when 조건식은 매우 강력하다. 2장에서 범위, 열거형, 봉인 클래스와 when조건식을 함께 사용하는 법을 자세히 설명할 것
- 일반적으로 셋 이상 조건이 필요하다면 when을 사용하고 단순한 경우에는 if를 사용함

## 텍스트 다루기
- 지금까지 텍스트를 다루는 예제를 확인했다.
- 문자열을 사용하지 않고는 (아주 이상하고 불편한 방법을 사용하지 않는 이상) Hello Kotlin도 출력하지 못하거나 적어도 매우 어색하고 불편했을 것임
- 이 절에는 텍스트를 효율적으로 다루기 위한 기능을 더 심도있게 살펴볼 것임

### 문자열 보간
- 위의 예제에서 만든 하뭇의 결과를 실제로 출력하기를 원한다고 치자
- 이미 앞의 예제들에서 봤겠지만 코틀린은 자바의 장황한 System.out.println 명령을 감싸고 있는 println()이라는 함수를 기본으로 제공함
- 중요한 것은 코틀린이 다른 최신 언어들과 마찬가지로 ${}문법을 활용한 문자열 보간(String Interpolation)을 지원한다는 것임
- 앞의 예제에서 이어지는 다음코드를 보자
```
val hero = "배트맨"
println("$hero, 그의 숙적은  ${archenemy(hero)}")
```
- 이 코드를 실행하면 다음과 같이 나옴
```
> 배트맨, 그의 숙적은 조커
```
- 함수 값을 넣을 때에는 중괄호로 감싸야 한다는 점에서 주의하셈
- 그냥 변수라면 중괄호는 생략할 수 있다

### 여러 줄 문자열
- 코틀린은 여러 줄 문자열(mutiline String, 미처리 문자열이라고도 함)을 지원한다.
- 다른 최신 언어에도 존재하는 기능이며 자바 15에는 텍스트 블록 이라는 이름으로 도입됨
- 개념은 매우 단순함. 여러줄에 걸쳐 있는 텍스트를 출력하고자 함.
- 예를 들어 루이스 캐롤이 지은 "이상한 나라의 앨리스"의 일부분을 출력하자
- 여러 줄을 하나의 문자열로 만들기 위해 다음과 같이 할 수 있음
```
//1번 케이스
println("반짝 반짝 작은 박쥐 \n" +
"어디 있는지 모르겠다. \n" +
"세상 꼭대기로 나네 \n" +
"하늘 속 쟁반 같구나 \n" +
"반짝반짝 작은 박쥐 \n" +
"어디 있는지 모르겠다! \n" +)
```
- 위 방법은 솔직히 귀찮다
- 아래 방법처럼 삼중따옴표로 문자열 리터럴을 정의할 수 있다.
```
//1번 케이스
println("""반짝 반짝 작은 박쥐
어디 있는지 모르겠다.
세상 꼭대기로 나네
하늘 속 쟁반 같구나
반짝반짝 작은 박쥐
어디 있는지 모르겠다!"""
)
```
- 같은 방법을 훨씬 더 꺠끗한 방법으로 해냈다. 하지만 위의 예제를 실행시켜보면 시의 들여쓰기가 예상과 다르게 출력되는 것을 알 수 있다.
- 여러 줄 문자열이 탭과 같은 공백 문자를 보존하기 때문에 생기는 현상임
- 제대로 출력하려면 다음과 같이 trimIndent() 함수를 호출해야함
```
println("""
반짝반짝 작은 박쥐
어디 있는지 모르겠다!
""".trimIndent())
```
- 여러 줄 문자열에는 또 다른 쓸모가 있다.
- 여러 줄 문자열 안에 있는 따옴표는 이스케이프 하지 않아도 된다는 점
- 다음 예제를 보자
```
println("소설 \" 이상한 나라의 앨리스 \ "에서 발췌")
```
- 일반 문자열에서는 이처럼 텍스트에 포함된 따옴표를 역슬래시로 이스케이프 해야 한다.

## 반복문
- 이제 또 다른 대표적 제어 구문인 반복문을 살펴보자
- 개발자라면 반복문이 굉장히 익숙할 것
- 반복문 없이 같은 코드 블록을 여러번 실행하기란 꽤 어려운 일임(하지만 이후의 장들에서 반복문을 사용하지 않고도 코드 블록을 반복하는 법을 배울 것)

### for-in 반복문
- 코틀린에서 가장 유용한 반복문은 아마도 for-in 반복문일 것이다.
- 이 반복문을 사용하면 문자열이나 자료 구조 등 반복자를 갖고 있는 모든 것에 대해 반복을 수행할 수 있다.
- 반복자에 대해서는 4장에서 배울 것
- 지금은 간단한 문자열에 반복문을 적용하는 것을 살펴보자
```
for (c in "Word"){
    println(c)
}
```
- 이 코드를 실행하면 다음과 같이 출력됨
```
>W
>o
>r
>d
```
- for-in 반복문은 지금까지 살펴본 모든 종류의 자료구조에서 사용할 수 있음
- 리스트 반복문 적용코드를 살펴보자
```
val jokers = listOf("히스 레저", "호아킨 피닉스", "잭 니콜슨")
for (j in jokers){
    println(j)
}
> 히스 레저
> 호아킨 피닉스
> 잭 니콜슨
```
- 이 반복문은 쓸모가 매우 많기 때문에 책에서 반복적으로 등장할 것

### for 반복문
- 어떤 언어에서는 for-in 반복문이 별개의 문법임
- 그러나 코틀린에서 for 반복문은 그저 범위 range에 적용한 for-in 반복문일 뿐
- 이해를 돕기 위해 한 자릿수를 모두 출력하는 for 반복문 예제를 보자

```
for (i in 0..9){
    println(i)
}
```
- 자바의 반복문과 다르게 생겼고 오히려 파이썬이 떠오를 것임
- 0과 9사이의 온점 2개를 범위 연산자라고 부름
- 위의 코드를 실행해 보면 범위가 상한을 포함한다는 것을 알 수 있을 것
- 즉 9를 포함한 모든 수가 출력됨
```
for(int i = 0; i<=9; i++)
```
- 만약 상한이 범위에 포함되지 않기를 원한다면 until 함수를 사용하자.
```
for(i in 0 until 10) {
    println("for" until $1) // 위의 코드와 똑같이 출력됨
}
```
- 역순으로 출력하고 싶다면 downTo 함수를 사용한다.
```
for (i in 9 downTo 0) {
    println("for downTo $1") // 9,8,7..
}
```
- 계속 until이나 downTo를 함수라고 부르는 것이 혼란스러울 수 있다.
- 함수보다 연산자처럼 보이기 때문이다.
- 이것은 중위 함수라고 하는 코틀린의 재미있는 기느응로 더 자세히 다룰 것임

### while 반복문
- 반복문은 다른 언어와 동일하기 때문에 간단히 살펴본다.
```
var x = 0
while (x < 10) {
    x++
    println("while $x")
}
```
- 이 코드는 1부터 10까지 수를 출력할 것이다. 여기서 변수x는 반드시 var를 이용해 선언해야 한다는 점에서 주의
- 자주 사용하지는 않지만, do while 반복문도 존재함

```
var x= 5
do {
    println("do while $x")
    x--
}while (x>0)
```
- 아마 코틀린에서 while 반복문을 사용할 일은 없을 것
- do-while 반복문은 더욱 그렇다.
- 이어지는 장들에서 같은일을 "코틀린 답게" 하는 방법을 살펴볼 것

## 클래스와 상속
- 코틀린은 다중 패러다임 언어이긴 하나 자바의 친척뻘임은 부인하 수 없음
- 자바는 클래스에 기반한 언어기에 코틀린에도 당연한 기능이다.
- 클래스, 인터페이스, 추상클래스, 데이터 클래스를 선언하는 문법을 다룰 것

### 클래스
- 클래스란 데이터와 메서드를 한데 모아놓은 것
- 클래스를 선언할 때 자바와 똑같이 class 키워드를 사용함
- 컴퓨터 게임을 만든다고 생각할 때 플레이어를 나타내는 클래스는 다음과 같이 정의할 수 있음
```
class Player{

}
```
- 클래스를 인스턴트화 하는 방법도 간단함
```
val player = Player()
```
- 코틀린에서는 new 키워드를 사용하지 않는다.
- 코틀린 컴파일러는 클래스 이름 뒤에 괄호() 가 있으면 새로운 인스턴스를 생성한느 것으로 인식함
- 위의 예제처럼 클래스 본문이 없는 경우에는 중괄호를 생략할 수 있음
```
class Player // 유효한 클래스 선언
```
- 아무런 함수나 속성이 없는 클래스는 특별히 쓸모 있지는 않지만, 4장에서 왜 이런 문법이 존재하며 어떻게 코틀린의 다른 기능과 어우러지는제 살펴볼 것

### 주 생성자
- 플레이어를 생성할 때 이름을 지정할 수 있음 좋을 것임
- 이를 위해 Player 클래스에 주 생성자를 추가해보자
```
class Player(name : String)
```
- 이제 다음과 같은 선언은 불가능함
```
val player = Player()
```
- 다음과 같이 새로운 플레이어 객체를 만들 때마다 이름을 넣어 줘야 함
```
val player = Player("Roland")
```
- 생성자를 잠시 뒤에 살펴보고, 지금은 속성에 대해 알아보자

### 속성
- 자바를 사용하다 보면 접근자(getter)와 설정자(setter)의 개념이 익숙해진다.
- 플레이어를 나타내는 클래스를 자바 스타일로 작성한 코틀린 코드는 아래와 같다.
```
class Player(name :String){
    private var name = String = name

    fun getName(): String {
        return name
    }

    fun setName(name : String) {
        this.name = name;
    }
}
```
- 플레이어의 이름을 알아내기 위해서는 getName() 메서드를 호출함.
- 플레이어의 이름을 바꾸려면 setName() 메서드를 호출함
- 매우 단순하긴 하지만 너무 많은 코드를 작성해야 함
- 코틀린의 this 키워드가 처음으로 등장했으니 짧게 뜻을 설명하고 넘어가면
- 다른 언어처럼 this는 해당 클래스의 현재 객체를 가리키는 참조를 담고 있다.
- 이 예제에서는 player 클래스의 인스턴스를 가리킴
- 그냥 클래스를 다음과 같이 작성하면 안되나
```
class Player {
    var name : String = ""
}
```
- 언뜻 괜찮은 방법같아 보이며 당연히 코드 양은 훨씬 줄었다.
- 플레이어 이름도 player.name 으로 간단히 알아낼 수 있다.
- 플레이어의 이름을 바꾸는 것도 훨씬 직관적임. player.name = "Alex"와 같이 하면됨
- 하지만 이런식으로 하면 객체를 통제할 수 없게됨
- 가령 Player를 불변으로 만들 수 없다.
- 모두에게 플레이어릐 이름을 읽을 권한을 주면, 동시에 이름을 수정할 권한까지갖게 됨
- 나중에 코드를 수정할 계획이라면 이건 심각한 문제가 될 수 있다.
- 이처럼 설정자를 사용할 때 통제할 수 있던 부분이 공개 필드를 사용할 떄 통제를 벗어나게 됨
- 코틀린의 속성은 이 문제를 해결해줌
```
class Player(val name: String)
```
- 주 생성자 절의 예제와 거의 똑같은 코드이지만 이제 Name 앞에 val 제한자가 생김
- 이렇게 하면 코틀린은 멤버와 동일한 이름의 접근자를 자동으로 만들어 줌
- 생성자를 사용해 속성의 값을 설정할 수 있고 이름을 사용해 접근할 수 있음
```
val player = Player("Alex")
println(player.name)
```
- 그러나 player 객테의 이름을 바꾸려 하면 오류가 발생함
```
Player.name = "Alexey" // "val cannot be reassigned" 오류 발생
```
- 속성을 값으로 선언했기 떄문에 읽기 전용이 됨
- 속성을 바꿀수 있게 하려면 가변 속성으로 선언해야 함
- 생서아에서 인자 var를 붙이면 자동으로 접근자와 설정자가 만들어짐
```
class Player(val name : String, var score: Int)
```
- 객체 생성 시에는 값을 전달할 수 없게 하려면 속성을 클래스 본문 안으로 이동시키면 됨
```
class Player(val name : String){
    var score : Int = 0
}
```
- score는 null 불가 타입이기 때문에 기본값을 설정해줘야함

### 설정자와 접근자 직접 정의하기
- 이제 플레이어의 점수를 쉽게 변경할 수 있음
- 하지만 점수가 유효하지 않은 값일 수 있음
- 예
```
player.score = -10
```
- 이처럼 가변 속성에 유효성 검사가 필요하다면 set 키워드를 사용해서 설정자를 명시적으로 정의해야함
```
class Player(val name: String){
    var score : Int = 0
        set (value) {
            field = if(value >= 0){
                value
            }else {
                0
            }
        }
}
```
- 여기서 value는 속성의 새 값이며 field는 현재 값임.
- 위의 코드에서는 새 값이 음수라면 기본 값을 사용함
- 자바좀 쳐봤으면 설정자 코드를 다음과 같이 작성하고 싶은 마음이 들 수 있음
```
set(value) {
    this.score = if(value >= 0) value else 0
}
```
- 코틀린에서 이 코드는 무한 재귀호출을 일으킴
- 가변 속성마다 설정자를 자동으로 생성하기 떄문에
- 그래서 자동으로 제공되는 field 라는 이름을 쓰는 것임
- 비슷한 방법으로 접근자도 직접 선언할 수 있음
```
class Player(name : String){
    val name= name
        get() = field.toUpperCase()
}
```
- 먼저 생성자의 인수로 받은 값을 같은 이름의 필드에 저장함.
- 그리고 이 속성의 모든 문자를 대문자로 바꿔서 반환하는 접근자를 정의함
```
println(player.name)
```

### 인터페이스
- 이미 다른 언어에서 인터페이스 개념을 많이 접했을 것이다.
- 정적 타입 언어에서 인터페이스는 어떤 클래스가 구현해야 하는 동작이 무엇인지 정의함
- 인터페이스를 정의할 때 그냥 interface 키워드를 사용
- 주사위 굴리는 인터페이스 예제
```
interface DiceRoller{
    fun rollDice(): Int
}
```
- 이 인터페이스를 구현하려면 클래스이름 디에 콜론을 붙이고 인터페이스 이름을 써줌
- 코틀린에서는 implements 키워드를 사용하지 않는다.
```
import kotlin.random.*
class Player (...) : DiceRoller
{
    ...
    fun rollDice() = Random.nextInt(0, 6)
}
```
- import 키워드도 여기서 처음 등장했음
- 이름에서 알 수 있듯 이 키워드는 코틀린 표준 라이브러리에서 kotlin.random과 같은 패키지를 불러들이는 역할을 함
- 코틀린 인터페이스는 기본 함수도 지원함.
- 만약 함수가 객체의 상태에 의존하지 않는다면 함수의 구현을 인터페이스에 작성하는 것
- 위의 예제에서 rollDice()는 단순히 0부터 5사이의 난수를 발생시키는 함수이기 떄문에 이에 해당됨
```
interface DiceRoller {
    fun rollDice () = Random.nextInt(0,6)
}
```

### 추상 클래스
- 역시 많은 사람에게 익숙한 개념안 추상 클래스는 직접 인스턴스화할 수 없다
- 반드시 다른 클래스가 먼저 추상 클래스를 상속해야 한다.
- 인터페이스와의 차이는 상태를 가진다는 것
- 게임판 위에서 플레이어를 움직일 수 있도록 하는 추상 클래스를 작성하면 아래와 같다.
```
abstract class Moveable(){
    private var x: Int = 0
    private var y: Int = 0
    fun move(x: Int, y: Int){
        this.x=x
        this.y=y
    }
}
```
- Moveable을 구현하는 클래스는 모두 move() 함수도 상속받게 될 것임
- 방금 에제에서 처음 등장한 private 키워드에 대해 더 자세히 알아보자

### 접근제한자
- 1장의 앞부분에서 private를 언급했지만 자세히 설명할 기회가 없었음
- private속성이나 함수는 선언된 클래스 안에서만 접근할 수 있음
- 위의 예제에서는 Moveable 클래스 내부에서만 x와 y에 접근할 수 있음
- 클래스와 속성은 기본적으로 public 임 따라서 public 접근 제한자는 매번 붙이지 않아도 됨
- 추상 클래스를 확장할 때는 추상 클래스 이름을 콜론 뒤에 붙이면 됨, extends는 사용하지 않음
```
class ActivePlayer(name: String) : Moveable(), DiceRoller{
    // 추상클래스와 인터페이스를 둘다 가져온것
}
```
- implements나 extends 키워드가 없다면 어떻게 추상 클래스와 인터페이스를 구분할 수 있을것인가
- 추상 클래스는 이름 뒤에 둥근 괄호를 붙여 생성자가 있음을 표시함
- 이후의 장들에서 이 문법이 어떻게 쓰이는지 살펴볼 것

### 상속
- 추상 클래스 말고 일반적인 클래스도 확장할 수 있음
- 추상 클래스를 확장했던 것과 똑같은 문법을 사용해서 player 클래스를 확장해보자
- ConfusedPlayer 클래스를 만들 텐데, 이 클래스는 (x, y) 좌표를 전달하면 (y, x)로 이동함
- 먼저 그냥 Player를 상속받는 클래스를 생성해보자
```
class ConfusedPlayer(name: String) : ActivePlayer(name)
```
- 부모 클래스 이름 뒤에 둥근 괄호를 왜 붙이는지 이제 이해할 수 있을 것이다.
- 이 괄호에 인자를 넣어서 부모 클래스의 생성자를 호출할 수 있다.
- 자바의 super 키워드와 비슷
- 놀랍게도 이 코드는 컴파일 되지 않음
- 코틀린에서 모든 클래스는 기본적으로 상속이 불가능한 최종 클래스이기 때문
- 다른 클래스가 상속받는 것을 허락하려면 클래스를 open으로 선언해야 함
```
open class ActivePlayer(...) : Moveable(), DiceRoller{
    ...
}
```
- 이제 move 메서드를 덮어써보자.
```
class ConfusePlayer(name : String) : Player(name){
    // move()는 반드시 open으로 선언돼 있어야 함
    override fun move(x: Int, y: Int){
        this.x = y // protected로 선언되어야 함
        this.y = x // protected로 선언되어야 함
    }
}
```
- 덮어 쓰기를 사용하면 특정 함수가 부모 클래스와 다르게 동작하도록 할 수 있음
- 자바에서는 @override가 선택 사항이지만 코틀린에서는 override 키워드를 반드시 붙여야 함
- 상위 타입의 메서드를 그냥 덮어 쓰는 것은 허용되지 않ㄷ기 떄문에 명시적으로 override를 사용하지 않으면 컴파일 되지 않는다.
- 이 코드에 두가지 문제가 있는데
  - 첫번째로 open으로 선언되지 않은 메서드는 덮어 쓸 수 없다.
  - 두번째로 자식 클래스에서는 플레이어의 좌표를 수정할 수 없다.
  - 좌표 속성은 둘 다 private으로 선언돼 있기 때문이다.
- protected 접근 제한자를 사용해 자식 클래스에서도 속성에 접근할 수 있도록 하고, 함수를 open으로 선언해 덮어쓸 수 있도록 하자
```
abstract class Moveable(){
    protected var x: Int = 0
    protected var y: Int = 0
    open fun move(x : Int , y: Int){
        this.x = y
        this.y = x
    }
}
```
- 이제 문제가 해결되었다. protected 키워드도 여기서 처음 등장했는데, 자바와 마찬가지로 이 접근 제한자는 속성이나 메서드가 자기 자신과 하위 클래스에서만 보이도록 함

### 데이터 클래스
- 코틀린에서는 모든 것이 생산성을 높이는 데 초점을 맞추고 있다는 것을 기억해야 함
- 자바 개발자가 가장 많이 하는 일 중 하나는 POJO(Plain Old java Object)를 만드는 것이다.(사실 잘 모르겠음)
- POJO가 생소하다면 접근자와 설정자, 그리고 equals 와 hashCode 메서드 구현만 갖고 있는 객체라고 생각하면 된다.
- POJO를 만들일이 너무 많다보니 아예걍 내장기능으로 만듬
- 이걸 데이터클래스라고 함
- 예제
```
data class User(val username: String , private val password: String)
```
- 이 코드는 2개의 접근자가 있고 설정자는 없는(모든 인수가 val로 선언돼 있는 것을 확신하라) 클래스를 생성함.
- 뿐만 아니라 equals, hashCode, clone 함수도 올바르게 정의됨
- 데이터 클래스는 코틀린에서 반복 코드 작업을 가장 획기적으로 줄여주는 기능 중 하나
- 일반적인 클래스와 똑같이 데이터 클래스도 자체 함수를 가질 수 있음
- 예제
```
data class User(val username: String, private val password: String) {
    fun hidePassword() = "*".repeat(password.length)
}
val user = User("Alexey", "abcd1234")
println(user.hidePassword())
```
- 일반적인 클래스와 비교했을 때 데이터 클래스에는 한가지 중요한 제약이 있다.
- 데이터 클래스가 항상 최종 클래스라는 것
- 다른 클래스가 데이터 클래스를 상속받는 것은 불가능함
- 그러나 equals와 hashCode를 자동으로 구현해주는 것을 생각하면 감수할 만 하다.

### 코틀린 데이터 클래스와 자바 레코드 비교
- 코틀린에서 영감을 얻어 자바 15에는 레코드라는 개념이 추가됨
- 위 예제를 자바 레코드로 표현하면 아래와 같다.
```
public record User(String username, String password) {}
```
- 두 문법이 모두 매우 간결하다. 어떤 차이가 있을까
  - 코틀린의 데이터 클래스에는 copy() 함수가 있지만 레코드에는 없음
  - 2장에서 프로토타임 디자인패턴을 다루면서 이 내용을 살펴볼 것
  - 레코드에서 모든 속성은 항상 final 임
  - 코틀린 식으로 표현하자면 레코드는 값만 지원하며 변수는 사용할 수 없다.
  - 데이터 클래스는 다른 클래스를 상속받을 수 있으나, 레코드는 불가능함
- 간단히 말해 데이터 클래스는 여러 면에서 레코드보다 낫다.
- 그러나 각각의 언어에선느 정말 좋은 기능임에는 틀림없음
- 또한 코틀린은 상호 운용성을 중시하는 언어이기 때문에 데이터 클래스에 간단한 표시만 해주면 자바에서 레코드로 사용할 수 있음
```
@JvmRecord
data class User(val username: String, val password: String)
```

## 확장함수
- 1장에서 다룰 마지막 기능은 확장함수임
- 간혹 final로 선언된 클래스의 기능을 갖고 싶을 때가 있다.
- 예를 들어 앞 절에서 구현한 hidePassword() 함수가 문자열에도 있다면 좋을 것
- 한가지 방법은 문자열을 감싸는 클래스를 직접 선언하는 것
```
data class Password(val password: String){
    fun hidePassword() = "*",repeat(password.length)
}
```
- 그러나 이 방법은 꽤 낭비적임
- 귀찮은 껍데기가 하나 더해졌다.
- 코틀린에는 더 좋은 방법이 있는데 클래스를 상속하지 않고 확장하려면 함수 
```
fun String.hidePassword() = "*".repeat(this.length)
```
- 일반적인 최상위 함수 선언과 거의 똑같아 보임
- 하지만 결정적인 차이가 있는데, 함수 이름 앞에 클래스 이름이 들어감.
- 이렇게 붙는 클래스 이름을 메서드 수신자 라고 부름
- 함수 본문에서는 this는 함수를 호출한 특정 문자열 객체를 가리킬 것임
- 이제 문자열을 선언하고 새로운 함수를 호출해보자
```
val password: String  =  "secretpassword"
println("비밀번호: ${password.hidePassword()}")
```
- 다음과 같이 출력됨
```
> Password: *******************
```
- 도대체 무슨 흑마술을 부린걸까?
- 방금 final 클래스에 함수를 추가했음
- 이론적으로는 불가능하다.
- 이건 코틀린 컴파일러 기능 중 하나임 확장 함수를 컴파일하면 대강 다음과 같은 코드가 나옴
```
fun hidePassword(this:String){
    "*".repeat(this.length)
}
```
- 보다시피 확장함수는 사실 그냥 보통의 전역함수임
- 다만 첫번째 인수가 확장되는 클래스의 인스턴스임
- 고 언어에서 구조체에 대해 메서드를 실행하는 것과 비슷하다고 볼 수있다.
- 따라서 비밀번호를 별표로 출력하는 코드를 다음과 같이 작성할 수 있음
```
val password: String = "secretpassword"
println("password: ${hidePassword(password)}")
```
- 이런 이유로 확장 함수는 클래스의 멤버 함수를 덮어 쓸 수는 없으며, private이나 protected로 선언된 속성에 접근할 수 없다.

## 디자인 패턴 소개
- 이제 코틀린의 기초 문법에 익숙(해진건진 모르지만)해졌으니 도대체 디자인패턴이라는 것이 무엇인지 살펴보자

### 디자인 패턴이란
- 일단 디자인 패턴에 대해 오해가 조금 있다
  - 디자인 패턴은 그저 언어가 지원하지 않는 기능을 구현하는 것
  - 동적 타입 언어에서 디자인 패턴은 필요하지 않다.
  - 디자인 패턴은 객체지향 언어에서만 유효함
  - 디자인 패턴은 엔터프라이즈 소프트웨어에서만 사용됨
- 디자인 패턴이란 사실 자주 발생하는 문제에 대한 검증된 해결책이다
- 개념적으로 볼 때 디자인 패턴은 특정 프로그래밍 언어(자바)나 언어군(예를들어 c언어와 그 동류)에 제한되지 않음
- 심지어 프로그래밍에 국한되지도 않음
- 소프트웨어 아키텍쳐 분야에서 디자인 패턴을 이야기하는 것을 들을 수 가 있는데, 서로 다른 여러 시스템이 효율적으로 의사소통을 하는 방법을 다룸
- 서비스 지향 아키텍쳐 패턴(SOA, Service-Oriented Architecture)이라는 것도 있고, SOA에서 파생돼 지난 몇넌간 떠오르고 있는 마이크로 서비스 디자인 패턴도 있음
- 틀림없이 미래에는 더 많은 종류의 디자인 패턴이생길 것
- 소프트웨어 개발을 벗어난 실생활에도 도처에 디자인 패턴이 있음
- 즉 어떤 문제에 대한 일반적인 해결책이 있음
  
### 디자인 과정
- 디자인 과정의 기본 절차는 다음과 같다.
  1. 당면한 문제가 무엇인지 정확하게 정의
  2. 다른 해결책을 생각해보고 장단점을 검토
  3. 주어진 제한 사항 내에서 문제를 해결하는 최적의 해결책을 선택

### 코틀린에서 디자인 패턴을 사용하는 이유
- 코틀린은 오늘날 현업에서 발생하는 문제를 풀기 위해 태어남
- 이어지는 장들에서 GoF 디자인 패턴에서 소개한 내용과 함께, 함수형 프로그래밍 패러다임에서 만들어진 디자인 패턴 및 어플리케이션의 동시 성 이슈를 다루기 위해 사용하는 디자인 패턴을 설명할 것
- 어떤 디자인 패턴은 굉장히 자주 사용되거나 매우 유용해서 코틀린 자체에 키워드나 표준 함수 형태로 내장돼 있음
- 어떤 디자인 패턴을 구현하려면 이제 별로 쓸모가 없음
- 세상이 발전해서 새로운 디자인 패턴이 그 자리를 차지했기 때문
- 그러나 어떤 경우든지 디자인 패턴과 모범 사례에 익숙해지면 개발자로 써 써먹을 수 있는 도구가 늘어나는 것이며, 동료들과 대화할 떄 사용하는 공통의 언어를 만드는 일임

## 요약
- 1장에서는 코틀린 프로그래밍 언어의 주요 목표를 설명함
- 변수를 선언하는 방법, 기본 타입 null 안전성, 타입 추론을 배움
- if나 when, for, while 등으로 프로그램의 흐름을 제어하는 방법을 살펴봄
- 클래스와 인터페이스를 정의하는 여러 키워드(클래스, 인터페이스, 데이터 클래스 추상 클래스)도 봤음.
- 새로운 클래스를 만드는 방법, 인터페이스를 구현하는 방법, 다른 클래스를 상속받는 방법도 배움
- 마지막으로 디자인 패턴의 쓸모가 무엇이며 코틀린에서 왜 디자인 패턴이 필요한지도 살펴봄
- 2장에서는 디자인 패턴의 세 종류 중 첫번째인 생성 패턴을 알아볼 것