# 2. 생성 패턴 사용
- 2장에서는 코틀린을 이용하여 고전 패턴의 한 종류인 생성패턴을 구현하는 방법을 살펴볼 것
- 생성 패턴은 '언제', 그리고 '어떻게' 객체를 '생성' 할지에 관한 디자인 패턴임
- 2장에서는 생성 패턴에 속하는 각 디자인 패턴이 해결하고자 하는 문제가 무엇이며, 코틀린에서 어떻게 그 목표를 달성하는지 배울 것

## 생성 패턴의 종류
- 싱글톤 패턴
- 팩토리 메서드 패턴
- 추상 팩토리 패턴
- 빌더 패턴
- 프로토타입 패턴
> 이 디자인 패턴들을 마스터하면 객체를 더 잘 관리할 수 있을 뿐 아니라 변경에 쉽게 대응하며 유지 보수하기 쉬운 코드를 작성할 수 있음

## 싱글톤 패턴
- 디자인 패턴을 별로 좋아하지 않는 사람조차도 싱글톤이란 이름 정도는 안다.
- 일반적으로 어떤 클래스가 있으면 원하는 만큼 인스턴스를 만들어 낼 수 있다.
- 예를 들어 나와 당신이 좋아하는 영화의 목록을 리스트로 만들어본다
```
val myFavoriteMovie = listOf("블랙호크다운", "블레이드 러너")
val yourFavoriteMovie = listOf(...)
```
- 별 문제없이 List인스턴스를 원하는 만큼 만들 수 있는데 클래스는 이런식으로 여러 인스턴스를 가질 수 있다.
- 싱글톤 디자인 패턴의 요구 사항은 두가지다.
  - 시스템에 인스턴스가 딱 하나만 존재해야 한다.
  - 시스템에 모든 부분에서 인스턴스에 접근할 수 있어야 한다.
- 자바를 비롯한 여러 언어에서 이 요구사항을 만족시키는 것은 꽤나 복잡한 문제이다. 먼저 클래스의 생성자를 private으로 만들어서 새로운 인스턴스가 생성되지 않도록 해야한다.
- 그리고 인스턴스 생성이 게으르고 스레드 안전하며 성능을 저해햐지 않도록 해야한다.
- 각 요구사항을 자세히 설명하면 다음과 같다.
  - 게으른 인스턴스 생선
    - 프로그램이 시작되지마자 싱글톤 인스턴스가 만들어지면 안됨
    - 인스턴스 생성에 많은 비용이 들 수 있기 대문.
    - 인스턴스 생성은 필요한 첫 순간에 이루어져야 한다
  - 스레드 안전한 인스턴스 생성
    - 두 스레드가 동시에 싱글톤 객체를 생성하려고 할 때 두 스레드가 같은 인스턴스를 획득해야 한다
    - 이 개념이 익숙하지 않은 독자를 위해 5장에서 자세히 설명할 것
  - 고성능의 인스턴스 생성
    - 많은 스레드가 동시에 싱글톤 객체를 생성하려고 할 때 스레드를 너무 오래 기다리게 하면 안됨
    - 잘못하면 실행이 중단될 수 있다.
- 코틀린에는 싱글톤 객체 생성을 쉽게 할 수 있도록 object라는 키워드가 도입됨
- 스칼라에도 같은 키워드가 존재한다.
- object 키워드를 사용하면 위의 모든 요구사항을 만족하는 싱글톤 객체를 구현할 수 있다
```
object 키워드에는 싱글톤 객체 생성 말고도 다른 쓰임새가 있다. 2장 뒷부분에서 더 자세히 설명할 것
```
- 싱글톤 객체는 일반적인 클래스와 동일한 방법으로 선언하되 생서자는 정의하지 않는다.
- 싱글톤 객체는 직접 인스턴스화 할 수 없기 때문
```
object NoMovieList
```
- 이제 NoMoviesList는 코드 어디서든 접근할 수 있으며 딱 1개의 객체만 존재할 것임
- 예제
```
val myFavoriteQuickAndAngryMovie = NoMovieList
val yourFavoriteQuickAndAngryMovie = NoMovieList
println(myFavoriteQuickAndAngryMovies === yourFavoriteQuickAndAngryMovies)
//true
```
- 두 변수가 메모리상의 같은 객체를 가리키는지 확인하기 위해 참조 동등성 비교 연산자를 사용함 근데 NoMovieList가 리스트이긴 한가?
- 영화 리스트를 출력하는 함수를 작성해보자
```
fun printMovies(movies: List<String>){
    for (m in movies){
        println(m)
    }
}
```
- 처음에 만든 영화 리스트를 전달하면 잘 컴파일 됨
```
//한줄에 하나씩 영화 제목을 출력
printMovies(myFavoriteMovies)
```
- 그러나 싱글톤으로 만든 빈 영화 리스트를 전달하면 아래와 같이 됨
```
printMovies(myFavoriteQuickAndAngryMovies)
// Type mismatch: ingerred type is NoMoviesList but
// List<String > was expected
```
- 영화 리스트 출력 함수는 인수로 문자열 리스트만 받을 수 있는데 NoMoviesList가 문자열 리스트라는 정보는 아무 데도 없기 때문에 (이름에서 유추할 수는 잇으나)오류가 발생한다.
- 다행히 코틀린에서는 싱글톤 객체도 인터페이스를 구현할 수 있음
- 그리고 제네릭 리스트를 나타내는 인터페이스가 존재함
```
object NoMoviesList : List<String>
```
- 이제 필수 함수를 구현하라는 메시지가 뜰 것
- 싱글톤 객체에 본문을 추가해서 필수 함수를 구현
```
object NoMoviesList : List<String>{
    override val size = 0
    override fun contains(element: String) = false
}
```
- 빈 리스트를 만들시 타입에 관계없이 코틀린의 emptyList() 함수 사용
- 싱글톤 객체는 클래스와 결정적으로 다른 부분이 있는데, 생성자를 가질 수 없다는 점
- 싱글톤 객체 초기화가 필요하다면(예를들어 처음에 설정 파일에서 데이터를 읽어와야 한다면)
- 다음과 같이 init 블록을 사용할 수 있음
```
object  logger {
    init {
        println("싱글톤 객체에 처음 접근하였다")
        // 여기에 초기화 로직 작성
    }
}
```
- 만약 싱글톤 객체에 한번도 접근하지 않는다면 초기화 로직은 실행되지 않고 따라서 자원이 절약됨
- 이를 게으른 초기화라고 함
- 객체의 생성을 제한하는 방법을 배웠으니 다음으로는 생성자를 직접 사용하지 않고 객체를 생성하는 방법을 살펴본다

## 팩토리 메서드 패턴
- 객체를 생성하는 메서드에 관한 디자인 패턴임
  - 객체를 생성하는 메서드가 왜 필요할까? 객체를 생성하기 위해 생성자가 있는게 아닌가?
- 생성자 만으로는 한계가 있기 때문이다.
- 예를들어 체스 게임을 만든다고 가정하면, 게임의 상태를 텍스트 파일로 저장하고 다시 읽어서 상태를 복원하는 기능을 구현하기 원함
- 체스판의 크기는 정해져 있다. 따라서 각 기물의 위치와 종류만 저장하면 된다.
- 여기서는 대수 기보법을 사용할 것인데 C3에 있는 퀸을 qc3라고 저장하고, A8에 있는 폰을 pa이라고 저장하는 식임
- 파일을 읽어서 문자열 배열을 만드는 기능은 이미 구현했다고 치자
  - 한편으로는 이 기능에 앞서 살펴본 싱글톤이 더 나음
- 기보가 리스트로 주어질 때 체스판을 만들어 내는 코드는 다음과 같음
```
// 모든 기물의 목록
val notations = listOf("pa8", "qc3",...)
val pisces = mutableListOf<ChessPiece>
for (n in notations) {
    pieces.add(createPiece(n))
}
println(pieces)
```
- createPiece함수를 구현하기 전에 먼저 기물의 공통적인 속성이 무엇인지 결정해야 함
- 기물을 나타내는 인터페이스를 다음과 같이 만들 것
```
interface ChessPiece{
    val file: Char
    val rank: Char
}
```
- 코틀린에서 인터페이스는 속성을 가질 수 있다는 사실에 주목하라.
- 굉장히 강력한 기능임
- 각 기물은 이 인터페이스를 구현하는 데이터 클래스가 될 것
```
data class Pawn(
    override val file : Char,
    override val rank : Char
) : ChessPiece

data class Queen(
    override val file: Char,
    override val rankL Char
) : ChessPiece
```
- 이제 createPiece함수를 작성하는 일만 남았다.
```
fun createPiece(notation: String): ChessPiece{
    
    // 분해선언
    val(type, file, rank) = notation.toCharArray()

    return when (type){
        'q' -> Queen(file, rank)
        'p' -> Pawn(file, rank)
        //
        else -> throw RuntimeException("알 수 없는 기물 종류 : $type")
    }
}
```
- 이 함수의 역할이 무엇인지 살펴보기 전 먼저 등장한 문법 4개를 소개한다.

#### toCharArray()
- toCharArray는 문자열을 문자 배열로 쪼개는 함수임
- 대수기보법에서 각 기물 3개의 문자로 표현된다고 가정하므로 0번 위치는 문자는 기물의 종류를, 1번 위치의 문자는 기물이 위치한 행 번호(file(파일)잉)를, 마지막 문자는 기물이 위치한 열 번호(Rank라고 부른다)를 나타냄

#### 분해선언
- 다음으로 3개의 값(type, file, rank)이 괄호 안에 있는 것을 볼 수 있음
- 이것을 분해 선언이라고 함
- 자바스크립트와 같은 언어에도 이런 문법이 있는데
- 모든 데이터 클래스는 이처럼 분해할 수 있다.
```
val type = notation.toCharArray()[0]
val file = notation.toCharArray()[1]
val rank = notation.toCharArray()[2]
```

#### when 표현식
- 위의 코드에서 when 표현식은 기물 종류를 나타내는 문자에 따라 ChessPiece 인터페이스를 구현하는 여러 구현체 중 하나를 인스턴스화 함
- 바로 이게 팩토리 메서드 디자인 패턴의 역할이라는 것을 기억해야 함
- 이해도를 높이기 위해 나머지 기물을 생성하는 로직도 자유롭게 작성해볼것
- 마지막으로 함수의 제일 아랫부분에 throw 표현식이 처음 등장함
- 이 표현식은 이름에서 알 수 있듯 예외를 '던져서' 프로그램의 정상 동작을 중단시킴
- 5장에서 예외를 다루는 법을 살펴볼 것
- 현업에서 팩토리 메서드 패턴은 라이브러리 코드가 XML이나 Json, YMAL같은 설정 파일을 파싱해서 런타임 객체를 생성할 때 자주 사용됨

## 정적 팩토리 메서드
- 팩토리 메서드 패턴과 이름이 비슷해서 자주 햇갈리는 디자인 패턴이 있음
- GoF의 책에도 등장하는 정적 팩토리 메서드 디자인 패턴이다.
- 정적 팩토리 메서드 디자인 패턴은 이펙티브 자바에서 좀 유명해짐(나중에 정리진행)
- 이 패턴을 이해하기 위해 자바의 표준 라이브러리에 있는 valueOf() 메서드를 보면 자바에는 문자열로부터 long 객체(64비트 정수)를 만드는 방법이 두가지가 있음
```
Long l1 = new Long("1"); 
Long l2 = Long.valueOf("1");
```
- 생성자나 valueOf()메서드 모두 문자열을 입력으로 받아 Long을 출력으로 만들어 냄
- 그러면 간단한 생성자 대신 정적 팩토리 메서드 디자인 패턴을 사용하는 이유는 뭘까

### 팩토리 메서드 디자인 패턴의 장점
- 다양한 생성자에 명시적인 이름을 붙일 수 있음.
  - 클래스에 생성자가 많은 경우에 특히 유용
- 일반적으로 생성자에서는 예외가 발생하지 않으리라는 기대가 있음
  - 그러나 클래스 인스턴스 생성이 절대 실패하지 않는 것은 아님
  - 예외가 불가피하다면 생성자보다는 일반적으로 메서드에서 발생하는 편이 훨씬 낫다.
- 생성자에 기대하는 것이 한가지 있다면 빠르다는 것
  - 그러나 생성하는 데에 시간이 오래 걸릴수밖에 없는 객체도 있다.
  - 그런 경우는 생성자 대신 정적 팩토리 메서드를 고려할 것
- 이 세가지는 대체로 스타일 측면의 장점임 하지만 정적 팩토리 메서드에는 기술적 장점도 있다.

### 캐시
- 정적 팩토리 메서드를 사용하면 캐시를 적용할 수 있음
- 실제로 Long도 캐시를 함
- valueOf()함수는 모든 값에 대해서 항상 새 객체를 반환하는 대신 이미 파싱한 적이 있는 값인지 확인함
- 만약 파싱한 적이 있다면 캐시된 객체로 반환
- 같은 값으로 정적 팩토리 메서드를 반복 호출하면 생성자를 사용하는 것에 비해 가비지 컬레렉션을 해야 하는 객체가 덜 생김

### 하위 클래스 생성
- 생성자를 호출하면 항상 그 클래스의 인스턴스를 얻음.
- 그러나 정적 팩토리 메서드에는 그런 제한이 없음
- 해당 크래스의 인스턴스를 생성할 수 있지만, 그 하위 클래스의 인스턴스를 만들어 낼 수 있다
- 코틀린으로 정적 팩토리 메서드를 구현하는 법을 먼저 살펴보고 나서 이 부분을 더 구체적으로 설명한다

### 코틀린에서 정적 팩토리 메서드 구현
- 2장 앞부분에서 싱글톤을 다루면서 object 키워드를 소개했다.
- 이번에는 Object 키워드를 이용해 동반객체를 만드는 방법을 살펴보자
- 자바에서는 정책 팩토리 메서드는 static으로 선언한다.
- 그러나 코틀린에는 그런 키워드가 없다.
- 대신 인스턴스에 속하지 않는 메서드는 동반 객체 내부에 선언할 수 있음
```
class Server(port : Long){
  init{
    println("$port 포트에서 서버가 시작됨")
  }
  companion object{
   // 동반객체
   fun withPort(port: Long) = Server(port) 
  }
}
```
> 동반 객체는 이름을 가질 수 있다.
> 예를들어 companion object parser로 선언할 수 있음
> 그러나 이 이름은 동반 객체의 목적이 무엇인지 조금 더 명확하게 알려주는 것 이상의 역할은 하지 않음

- 객체 선언 앞에 붙은 companion 키워드에 주목
- 또한 싱글톤 패턴과 달리 객체를 패키지 수준에 선언하지 않고 클래스 내부에 선언함
- 이 객체는 자체 메서드를 가진다. 그래서 뭐가 좋은 것인지 궁금할 수도 있다.
- 자바의 성적 메서드와 마찬가지로 동반 객체는 해당 클래스에 처음 접근할 때 게으르게 생성됨
```
Server.withPort(8080) // 8080포트에서 서버가 시작됨
```
> 하나의 클래스에는 1개의 동반 객체만 존재할 수 있음.

- 인스턴스가 정적 팩토리 메서드를 통해서만 생성되기를 원할 때도 있다.
- 그럴 땐 객체의 기본 생성자를 private으로 선언하면 됨
- 예제
```
class Server private constructor(port : Long){
  ...
}
```
- 이제 이 클래스는 정적 팩토리 메서드를 통해서만 인스턴스화가 가능
```
val server = Server(8080) // 실패
val server = Server.withPort(8080) // 성공
```

## 추상 팩토리 패턴
- 추상 팩토리 패턴은 많은 오해를 사는 디자인 패턴임
  - 매우 복잡하고 이상한 패턴이라는 것
  - 그러나 사실은 굉장히 간단하다.
  - 팩토리 메서드 패턴을 이해하면 추상팩토리도 금세 이해할 수 있을것이다.
  - 추상 팩토리만 팩토리를 만들어내는 팩토리이기 때문
- 팩토리는 다른 클래스를 만들어 낼 수 있는 함수나 클래스임
- 추상팩토리는 여러 팩토리 메서드를 감싸는 클래스

### 추상팩토리의 주 사용처
- 현업에서 추상팩토리 디자인패턴은 프레임워크나 라이브러리가 파일에서 구성설정을 읽어드릴때 자주 사용되는데 스프링 프레임워크가 좋은예다.
  
