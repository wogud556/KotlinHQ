# 2. 생성 패턴 사용
- 2장에서는 코틀린을 이용하여 고전 패턴의 한 종류인 생성패턴을 구현하는 방법을 살펴볼 것
- 생성 패턴은 '언제', 그리고 '어떻게' 객체를 '생성' 할지에 관한 디자인 패턴임
- 2장에서는 생성 패턴에 속하는 각 디자인 패턴이 해결하고자 하는 문제가 무엇이며, 코틀린에서 어떻게 그 목표를 달성하는지 배울 것

## 생성 패턴의 종류
- 싱글톤 패턴
- 팩토리 메서드 패턴
- 추상 팩토리 패턴
- 빌더 패턴
- 프로토타입 패턴
> 이 디자인 패턴들을 마스터하면 객체를 더 잘 관리할 수 있을 뿐 아니라 변경에 쉽게 대응하며 유지 보수하기 쉬운 코드를 작성할 수 있음

## 싱글톤 패턴
- 디자인 패턴을 별로 좋아하지 않는 사람조차도 싱글톤이란 이름 정도는 안다.
- 일반적으로 어떤 클래스가 있으면 원하는 만큼 인스턴스를 만들어 낼 수 있다.
- 예를 들어 나와 당신이 좋아하는 영화의 목록을 리스트로 만들어본다
```
val myFavoriteMovie = listOf("블랙호크다운", "블레이드 러너")
val yourFavoriteMovie = listOf(...)
```
- 별 문제없이 List인스턴스를 원하는 만큼 만들 수 있는데 클래스는 이런식으로 여러 인스턴스를 가질 수 있다.
- 싱글톤 디자인 패턴의 요구 사항은 두가지다.
  - 시스템에 인스턴스가 딱 하나만 존재해야 한다.
  - 시스템에 모든 부분에서 인스턴스에 접근할 수 있어야 한다.
- 자바를 비롯한 여러 언어에서 이 요구사항을 만족시키는 것은 꽤나 복잡한 문제이다. 먼저 클래스의 생성자를 private으로 만들어서 새로운 인스턴스가 생성되지 않도록 해야한다.
- 그리고 인스턴스 생성이 게으르고 스레드 안전하며 성능을 저해햐지 않도록 해야한다.
- 각 요구사항을 자세히 설명하면 다음과 같다.
  - 게으른 인스턴스 생선
    - 프로그램이 시작되지마자 싱글톤 인스턴스가 만들어지면 안됨
    - 인스턴스 생성에 많은 비용이 들 수 있기 대문.
    - 인스턴스 생성은 필요한 첫 순간에 이루어져야 한다
  - 스레드 안전한 인스턴스 생성
    - 두 스레드가 동시에 싱글톤 객체를 생성하려고 할 때 두 스레드가 같은 인스턴스를 획득해야 한다
    - 이 개념이 익숙하지 않은 독자를 위해 5장에서 자세히 설명할 것
  - 고성능의 인스턴스 생성
    - 많은 스레드가 동시에 싱글톤 객체를 생성하려고 할 때 스레드를 너무 오래 기다리게 하면 안됨
    - 잘못하면 실행이 중단될 수 있다.
- 코틀린에는 싱글톤 객체 생성을 쉽게 할 수 있도록 object라는 키워드가 도입됨
- 스칼라에도 같은 키워드가 존재한다.
- object 키워드를 사용하면 위의 모든 요구사항을 만족하는 싱글톤 객체를 구현할 수 있다
```
object 키워드에는 싱글톤 객체 생성 말고도 다른 쓰임새가 있다. 2장 뒷부분에서 더 자세히 설명할 것
```
- 싱글톤 객체는 일반적인 클래스와 동일한 방법으로 선언하되 생서자는 정의하지 않는다.
- 싱글톤 객체는 직접 인스턴스화 할 수 없기 때문
```
object NoMovieList
```
- 이제 NoMoviesList는 코드 어디서든 접근할 수 있으며 딱 1개의 객체만 존재할 것임
- 예제
```
val myFavoriteQuickAndAngryMovie = NoMovieList
val yourFavoriteQuickAndAngryMovie = NoMovieList
println(myFavoriteQuickAndAngryMovies === yourFavoriteQuickAndAngryMovies)
//true
```
- 두 변수가 메모리상의 같은 객체를 가리키는지 확인하기 위해 참조 동등성 비교 연산자를 사용함 근데 NoMovieList가 리스트이긴 한가?
- 영화 리스트를 출력하는 함수를 작성해보자
```
fun printMovies(movies: List<String>){
    for (m in movies){
        println(m)
    }
}
```
- 처음에 만든 영화 리스트를 전달하면 잘 컴파일 됨
```
//한줄에 하나씩 영화 제목을 출력
printMovies(myFavoriteMovies)
```
- 그러나 싱글톤으로 만든 빈 영화 리스트를 전달하면 아래와 같이 됨
```
printMovies(myFavoriteQuickAndAngryMovies)
// Type mismatch: ingerred type is NoMoviesList but
// List<String > was expected
```
- 영화 리스트 출력 함수는 인수로 문자열 리스트만 받을 수 있는데 NoMoviesList가 문자열 리스트라는 정보는 아무 데도 없기 때문에 (이름에서 유추할 수는 잇으나)오류가 발생한다.
- 다행히 코틀린에서는 싱글톤 객체도 인터페이스를 구현할 수 있음
- 그리고 제네릭 리스트를 나타내는 인터페이스가 존재함
```
object NoMoviesList : List<String>
```
- 이제 필수 함수를 구현하라는 메시지가 뜰 것
- 싱글톤 객체에 본문을 추가해서 필수 함수를 구현
```
object NoMoviesList : List<String>{
    override val size = 0
    override fun contains(element: String) = false
}
```
- 빈 리스트를 만들시 타입에 관계없이 코틀린의 emptyList() 함수 사용
- 싱글톤 객체는 클래스와 결정적으로 다른 부분이 있는데, 생성자를 가질 수 없다는 점
- 싱글톤 객체 초기화가 필요하다면(예를들어 처음에 설정 파일에서 데이터를 읽어와야 한다면)
- 다음과 같이 init 블록을 사용할 수 있음
```
object  logger {
    init {
        println("싱글톤 객체에 처음 접근하였다")
        // 여기에 초기화 로직 작성
    }
}
```
- 만약 싱글톤 객체에 한번도 접근하지 않는다면 초기화 로직은 실행되지 않고 따라서 자원이 절약됨
- 이를 게으른 초기화라고 함
- 객체의 생성을 제한하는 방법을 배웠으니 다음으로는 생성자를 직접 사용하지 않고 객체를 생성하는 방법을 살펴본다

## 팩토리 메서드 패턴
- 객체를 생성하는 메서드에 관한 디자인 패턴임
  - 객체를 생성하는 메서드가 왜 필요할까? 객체를 생성하기 위해 생성자가 있는게 아닌가?
- 생성자 만으로는 한계가 있기 때문이다.
- 예를들어 체스 게임을 만든다고 가정하면, 게임의 상태를 텍스트 파일로 저장하고 다시 읽어서 상태를 복원하는 기능을 구현하기 원함
- 체스판의 크기는 정해져 있다. 따라서 각 기물의 위치와 종류만 저장하면 된다.
- 여기서는 대수 기보법을 사용할 것인데 C3에 있는 퀸을 qc3라고 저장하고, A8에 있는 폰을 pa이라고 저장하는 식임
- 파일을 읽어서 문자열 배열을 만드는 기능은 이미 구현했다고 치자
  - 한편으로는 이 기능에 앞서 살펴본 싱글톤이 더 나음
- 기보가 리스트로 주어질 때 체스판을 만들어 내는 코드는 다음과 같음
```
// 모든 기물의 목록
val notations = listOf("pa8", "qc3",...)
val pisces = mutableListOf<ChessPiece>
for (n in notations) {
    pieces.add(createPiece(n))
}
println(pieces)
```
- createPiece함수를 구현하기 전에 먼저 기물의 공통적인 속성이 무엇인지 결정해야 함
- 기물을 나타내는 인터페이스를 다음과 같이 만들 것
```
interface ChessPiece{
    val file: Char
    val rank: Char
}
```
- 코틀린에서 인터페이스는 속성을 가질 수 있다는 사실에 주목하라.
- 굉장히 강력한 기능임
- 각 기물은 이 인터페이스를 구현하는 데이터 클래스가 될 것
```
data class Pawn(
    override val file : Char,
    override val rank : Char
) : ChessPiece

data class Queen(
    override val file: Char,
    override val rankL Char
) : ChessPiece
```
- 이제 createPiece함수를 작성하는 일만 남았다.
```
fun createPiece(notation: String): ChessPiece{
    
    // 분해선언
    val(type, file, rank) = notation.toCharArray()

    return when (type){
        'q' -> Queen(file, rank)
        'p' -> Pawn(file, rank)
        //
        else -> throw RuntimeException("알 수 없는 기물 종류 : $type")
    }
}
```
- 이 함수의 역할이 무엇인지 살펴보기 전 먼저 등장한 문법 4개를 소개한다.

#### toCharArray()
- toCharArray는 문자열을 문자 배열로 쪼개는 함수임
- 대수기보법에서 각 기물 3개의 문자로 표현된다고 가정하므로 0번 위치는 문자는 기물의 종류를, 1번 위치의 문자는 기물이 위치한 행 번호(file(파일)잉)를, 마지막 문자는 기물이 위치한 열 번호(Rank라고 부른다)를 나타냄

#### 분해선언
- 다음으로 3개의 값(type, file, rank)이 괄호 안에 있는 것을 볼 수 있음
- 이것을 분해 선언이라고 함
- 자바스크립트와 같은 언어에도 이런 문법이 있는데
- 모든 데이터 클래스는 이처럼 분해할 수 있다.
```
val type = notation.toCharArray()[0]
val file = notation.toCharArray()[1]
val rank = notation.toCharArray()[2]
```

#### when 표현식
- 위의 코드에서 when 표현식은 기물 종류를 나타내는 문자에 따라 ChessPiece 인터페이스를 구현하는 여러 구현체 중 하나를 인스턴스화 함
- 바로 이게 팩토리 메서드 디자인 패턴의 역할이라는 것을 기억해야 함
- 이해도를 높이기 위해 나머지 기물을 생성하는 로직도 자유롭게 작성해볼것
- 마지막으로 함수의 제일 아랫부분에 throw 표현식이 처음 등장함
- 이 표현식은 이름에서 알 수 있듯 예외를 '던져서' 프로그램의 정상 동작을 중단시킴
- 5장에서 예외를 다루는 법을 살펴볼 것
- 현업에서 팩토리 메서드 패턴은 라이브러리 코드가 XML이나 Json, YMAL같은 설정 파일을 파싱해서 런타임 객체를 생성할 때 자주 사용됨

## 정적 팩토리 메서드
- 팩토리 메서드 패턴과 이름이 비슷해서 자주 햇갈리는 디자인 패턴이 있음
- GoF의 책에도 등장하는 정적 팩토리 메서드 디자인 패턴이다.
- 정적 팩토리 메서드 디자인 패턴은 이펙티브 자바에서 좀 유명해짐(나중에 정리진행)
- 이 패턴을 이해하기 위해 자바의 표준 라이브러리에 있는 valueOf() 메서드를 보면 자바에는 문자열로부터 long 객체(64비트 정수)를 만드는 방법이 두가지가 있음
```
Long l1 = new Long("1"); 
Long l2 = Long.valueOf("1");
```
- 생성자나 valueOf()메서드 모두 문자열을 입력으로 받아 Long을 출력으로 만들어 냄
- 그러면 간단한 생성자 대신 정적 팩토리 메서드 디자인 패턴을 사용하는 이유는 뭘까

### 팩토리 메서드 디자인 패턴의 장점
- 다양한 생성자에 명시적인 이름을 붙일 수 있음.
  - 클래스에 생성자가 많은 경우에 특히 유용
- 일반적으로 생성자에서는 예외가 발생하지 않으리라는 기대가 있음
  - 그러나 클래스 인스턴스 생성이 절대 실패하지 않는 것은 아님
  - 예외가 불가피하다면 생성자보다는 일반적으로 메서드에서 발생하는 편이 훨씬 낫다.
- 생성자에 기대하는 것이 한가지 있다면 빠르다는 것
  - 그러나 생성하는 데에 시간이 오래 걸릴수밖에 없는 객체도 있다.
  - 그런 경우는 생성자 대신 정적 팩토리 메서드를 고려할 것
- 이 세가지는 대체로 스타일 측면의 장점임 하지만 정적 팩토리 메서드에는 기술적 장점도 있다.

### 캐시
- 정적 팩토리 메서드를 사용하면 캐시를 적용할 수 있음
- 실제로 Long도 캐시를 함
- valueOf()함수는 모든 값에 대해서 항상 새 객체를 반환하는 대신 이미 파싱한 적이 있는 값인지 확인함
- 만약 파싱한 적이 있다면 캐시된 객체로 반환
- 같은 값으로 정적 팩토리 메서드를 반복 호출하면 생성자를 사용하는 것에 비해 가비지 컬레렉션을 해야 하는 객체가 덜 생김

### 하위 클래스 생성
- 생성자를 호출하면 항상 그 클래스의 인스턴스를 얻음.
- 그러나 정적 팩토리 메서드에는 그런 제한이 없음
- 해당 크래스의 인스턴스를 생성할 수 있지만, 그 하위 클래스의 인스턴스를 만들어 낼 수 있다
- 코틀린으로 정적 팩토리 메서드를 구현하는 법을 먼저 살펴보고 나서 이 부분을 더 구체적으로 설명한다

### 코틀린에서 정적 팩토리 메서드 구현
- 2장 앞부분에서 싱글톤을 다루면서 object 키워드를 소개했다.
- 이번에는 Object 키워드를 이용해 동반객체를 만드는 방법을 살펴보자
- 자바에서는 정책 팩토리 메서드는 static으로 선언한다.
- 그러나 코틀린에는 그런 키워드가 없다.
- 대신 인스턴스에 속하지 않는 메서드는 동반 객체 내부에 선언할 수 있음
```
class Server(port : Long){
  init{
    println("$port 포트에서 서버가 시작됨")
  }
  companion object{
   // 동반객체
   fun withPort(port: Long) = Server(port) 
  }
}
```
> 동반 객체는 이름을 가질 수 있다.
> 예를들어 companion object parser로 선언할 수 있음
> 그러나 이 이름은 동반 객체의 목적이 무엇인지 조금 더 명확하게 알려주는 것 이상의 역할은 하지 않음

- 객체 선언 앞에 붙은 companion 키워드에 주목
- 또한 싱글톤 패턴과 달리 객체를 패키지 수준에 선언하지 않고 클래스 내부에 선언함
- 이 객체는 자체 메서드를 가진다. 그래서 뭐가 좋은 것인지 궁금할 수도 있다.
- 자바의 성적 메서드와 마찬가지로 동반 객체는 해당 클래스에 처음 접근할 때 게으르게 생성됨
```
Server.withPort(8080) // 8080포트에서 서버가 시작됨
```
> 하나의 클래스에는 1개의 동반 객체만 존재할 수 있음.

- 인스턴스가 정적 팩토리 메서드를 통해서만 생성되기를 원할 때도 있다.
- 그럴 땐 객체의 기본 생성자를 private으로 선언하면 됨
- 예제
```
class Server private constructor(port : Long){
  ...
}
```
- 이제 이 클래스는 정적 팩토리 메서드를 통해서만 인스턴스화가 가능
```
val server = Server(8080) // 실패
val server = Server.withPort(8080) // 성공
```

## 추상 팩토리 패턴
- 추상 팩토리 패턴은 많은 오해를 사는 디자인 패턴임
  - 매우 복잡하고 이상한 패턴이라는 것
  - 그러나 사실은 굉장히 간단하다.
  - 팩토리 메서드 패턴을 이해하면 추상팩토리도 금세 이해할 수 있을것이다.
  - 추상 팩토리만 팩토리를 만들어내는 팩토리이기 때문
- 팩토리는 다른 클래스를 만들어 낼 수 있는 함수나 클래스임
- 추상팩토리는 여러 팩토리 메서드를 감싸는 클래스

### 추상팩토리의 주 사용처
- 현업에서 추상팩토리 디자인패턴은 프레임워크나 라이브러리가 파일에서 구성설정을 읽어드릴때 자주 사용되는데 스프링 프레임워크가 좋은예다.
  
### 추상 팩토리 디자인의 예제
- 추상 팩토리 디자인패턴이 어떻게 동작하는지 이해하기 위해 이전 절의 서버 예제를 계속 사용할 것
- 이번에는 서버 클래스에서 사용하는 설정 파일이 다음과 같이 YAML로 작성되 있다고 보자
```
server:
  port: 8080
environment: production
```
- 지금부터 해야할 일은 이 설정 파일을 읽어서 객체를 셍서하는 것임
- 그러나 여기서는 두 종류의 객체를 생성할 것임
- 두 객체는 서로 관련돼 있으나 형제 관계 까지는 아님
- 두객체를 위한 인터페이스를 먼저 정의한다.

```
interface Property{
  val name: String
  val value : Any
}
```
- 이제 데이터 클래스 대신 인터페이스를 반환할 것
- 왜 이렇게 해야 하는지는 나중에 알게 될 것
```
interface ServerConfiguration{
  val properties: List<Property>
}
```
- 이제 나중에 사용할 기본 코드를 구현함
```
data class PropertyImpl(
  override val name: String
  override val value: Any
) : Property
data class Server ConfigurationImpl{
  override val properties: List<Property>
} : ServerConfiguration
```
- 서버 설정에는 속성의 리스트만 있고, 각 속성은 이름 객체와 값 객체로 이뤄짐
- Any 타입이 처음 등장했다. 코틀린의 Any는 자바의 object에 해당된다.
- 그러나 중요한 타이가 있는데 null을 가질 수 있다는 것임
- 첫번쨰 팩토리 메서드를 생서해보면, 이 메서드는 문자열로 된 Property객체를 생성함
```
fun property(prop: String): Property{
  val (name, value) = prop.split(",")
  return when(name) {
    "port" -> PropertyImpl(name, value.trim().toInt())
    "environment" -> PropertyImpl(name, value.trim())
    else -> throw RuntimeException("알 수 없는 속성: $name")
  }
}
```
- 다른 언어들과 마찬가지로 trim() 함수는 문자열에서 공백을 제거하는 함수임
- 이제 이 서비스의 포트와 환경을 나타내는 두 속성을 만들어보자
```
val portProperty = property("port : 8080")
val environment = property("environment: production")
```
- 이 코드에는 작은 문제가 있다. 어떤 문제인지 이해하기 위해 port 속성의 값을 다른 변수에 저장한다
```
val port: Int = portProperty.value
// Type mismatch: inferred type is Any but Int was expected
```
- 이미 팩토리 메서드에서 port가 int타입으로 파싱된 것을 확인함
- 그러나 이 정보는 사라져버렸는데, value 가 Any타입으로 선언되어있기 때문이다.
- 그래서 value는 String일수도 Int일수도 있고, 다른 어떤 타입이든 될 수 있다.
- 이 문제를 해결하려면 다른 도구가 필요함

### 캐스팅
- 타입 언어에서 캐스팅은 컴파일러가 추론한 타입 대신 프로그래머가 지정한 타입을 사요하도록 강제하는것.
- 값의 타입이 무엇인지 확실히 알고 있다면 다음과 같이 '안전하지 않은' 캐스팅을 할 수 있다.
```
val port: Int = protProperty.value as Int
```
- 만약 값이 기대한 값과 타입이 다른 경우 컴파일러 경고 메시지도 없이 프로그램이 비정상 종료됨.
- 그래서 안전하지 않은 이라는 수식어가 붙는다
- 한편 '안전한' 캐스팅도 사용할 수 있다.
```
val port: Int? = portProperty.value as? Int
```
- 안전한 캐스팅은 프로그램 종료시키지 않음
- 그러나 객체가 기대한 타입과 다른 경우 null을 반환한다.
- 이번에는 port 변수가 null 값을 가질 수 있는 Int? 타입으로 선언된 것에 주목하라.
- 따라서 컴파일 타임에 기대했던 것과 다른 타입을 갖느 경우까지도 명시적으로 고려해서 코드를 작성해야 함

### 하위 클래스 생성
- 이번에는 캐스팅 말고 다른 접근을 시도하자
- Any 타입의 값을 갖는 단일 구현체를 사용하는 대신 2개의 구분된 구현체를 사용할 것
```
data class IntProperty(
  override val name: String,
  override val value: Int
): Property

data class StringProperty(
  override val name: String,
  override val value: String
): Property
```
- 두 클래스 중 하나를 리턴하려면 앞서 구현한 팩토리 메서드를 약간 수정해야 함
```
fun property(prop: String): Property{
  val(name, value) = prop.split(":")

  return when(name) {
    "port" -> IntProperty(name, value.trim().toInt())
    "environment" -> StringProperty(name, value.trim())
    else -> throw RuntimeException("알 수 없는 속성: $name")
  }
}
```
- 이제 문제가 없을 것 같지만 컴파일을 시도하면 여전히 오류가 발생함
```
val portProperty = Parser.property("port: 8080")
val port: Int = portProperty.value
```
- 이제 구체 클래스는 2개가 생김.
- 그렇지만 컴파일러는 아직까지 파싱된 속성이 IntProperty인지 StringProperty인지 구분하지 못하며 그저 Property인터페이스를 구현하고 있다는 것만 안다.
- 그리고 그 값은 여전히 Any타입임
```
> Type mismatch: inferred type is Any but Int was expected
```
- 다른 기법이 필요하다. 바로 스마트 캐스팅이라 부르는 기법

### 스마트 캐스팅
- is 키워드를 사용하면 객체 타입을 검사할 수 있다.
```
println(portProperty is IntProperty) // true
```
- 그러나 코틀린 컴파일러는 굉장히 똑똑함
- if 표현식으로 타입을 검사한 뒤에는 portProperty가 확실히 IntProperty라는 것을 알 수 있다.
- 그래서 안전하게 캐스팅할 수 있다.
- 코틀린 컴파일러는 알아서 해줌
```
if(portProperty is IntProperty){
  val port: Int = portProperty.value
}
```
- 더 이상 컴파일 오류가 발생하지 않는다.
- 캐스팅 결과가 null인 경우를 처리할 필요도 없음
- 스마트 캐스팅은 null에 대해서도 동작함
- 코틀린의 타입 계층에서 null 불가 타입인 Int는 null기능인 Int?의 하위 타입임
- Int 뿐 아니라 모든 타입이 마찬가지이다.
- 앞서 안전한 캐스팅이 실패하면 Null을 반환한다고 했음
```
val port: Int? = portProperty.value as? Int
```
- 만약 port 가 null인지 검사해서 null 이 아니라는 것을 확인했다면 port는 자동으로 null불가 타입으로 캐스팅됨
```
if (port != null){
  val port: Int = port
}
```
- 1장에서 값은 재할당 될 수 없다고 했는데 여기선 port값을 두번 정의했다.
- 이게 어떻게 가능한건가 했는데 코틀린의 변수 가리기라는 기능이다.

### 변수 가리기
- 먼저 변수 가리기가 없었다면 어떤 코드가 됐을지 생각해보라
- 이름이 서로 다른 변수 2개를 선언해야 했을 것
```
val portOrNull : Int? = portProperty.value as? Int
if(portOrNull != null){
  val port: Int = portOrNull //Ok
}
```
- 하지만 이 코드는 낭비적인데, 두가지 이유 떄문임
  - 첫번째로 변수 이름이 상당히 길어짐
  - 둘쨰로 이 코드 이후에 portOrNull 변수가 쓰일 일이 없다는 것
- null값은 그다지 쓸모 있는 값이 아니기 때문.
- 변수 가리기를 활용하면 같은 이름의 값을 다른 시야에 정의할 수 있음
- 변수 가리기를 사용하면 자칫 혼란스럽고 오류가 있는 코드를 작성하기 쉽게 때문에 주의가 필요함
- 그러나 이런 기능의 존재를 알 고 있는 것은 주요함
- 그럼에도 변수 이름은 최대한 명시적으로 지을 것을 권고함

### 팩토리 메서드의 모음
- 잠깐 샛길로 빠져 캐스팅과 변수 가리개를 살펴봤으니 다시 이전 코드 예레로 돌아가 두번째 팩토리 메서드를 구현해보자.
- 이 메서드는 Server 설정 객체를 생성할 것임
```
fun server(propertyStrings: List<String>): ServerConfiguration {
  val parsedProperties = mutableListOf<Property>()
  for(p in propertyStrings){
    parsedProperties += property(p)
  }
}
```
- 이 메서드는 앞서 구현한 property() 팩토리 메서드를 활용해 입력으로 받은 설정 파일의 각 줄을 Property 객체로 변환함
- 두번째 팩토리 메서드도 잘 동작할하는 것을 다음과 같이 테스트 할 수 있음
```
println(server(listOf("port: 8080", "environment: production")))
> ServerConfigurationImpl(properties=[IntProperty(name=port, value=8080),
StringProperty(name=enviornment, value = production)])
```
- 이 두 메서드는 서로 연관돼 있기 떄문에 같은 클래스에 두는 것이 좋다.
- 이 클래스를 Parser라고 부르자.
- 여기서는 파일을 실제로 파싱하지는 않고 이미 내용이 줄 단위로 주어진다고 가정함
- 그러나 파일의 내용을 실제로 읽는 작업도 그리 어렵지는 앖다(책의 뒷부분을 읽다 보면 알 수 있을 것)
- 이전 절에서 배운 정적 팩토리 메서드와 동반 객체 문법도 사용할 수 있다.
```
class Parser{
  companion object{
    fun property(prop: String): Property{

    }
    fun server(propertyStrings: List<String>): ...{

    }
  }
}
```
- 이 패턴을 사용하면 연관된 객체를 가족처럼 하나로 묶을 수 있다.
- 여기서는 ServerConfig이 여러 속성의 부모 역할을 한다.
- 위의 코드는 추상 팩토리를 구현하는 한 가지 방법에 지나지 않음
- 대신 인터페이스를 구현하는 방법도 있다.
```
interface Parser{
  fun property(prop: String): Property
  fun server(propertyStrings: List<String>) : ServerConfiguration
}
class YamlParser: Parser{
  // Yaml 파일을 읽는 구현체
}
class JsonParser: Parser{
  // Json 파일을 읽는 구현체
}
```
- 팩토리 메서드가 커져서 코드 양이 많아지는 경우 이 방법이 더 나을 것
- 마지막으로, 실제 코드에서는 추상 팩토리가 어디에서 쓰이는지 궁금할 수 있다.
- 한가지 예는 java.util.Collections 클래스임
- 이 클래스에는 emptyMap, emptyList, emptySet과 같은 메서드가 있는데 모두 다른 클래스를 생성한다.
- 그러나 동시에 모두 집합 자료 구조라는 공통점을 갖고 있음

## 빌더패턴
- 매우 단순한 객체는 생성자 하나로 충분할 때가 있다.
- 그러나 객체 생성이 굉장히 복잡하고 많은 매개변수를 사용할 때도 있음
- 이전 절에 더 나은 생성자를 사용할 수도 있도록 하는 패턴을 이미 살펴봄
- 바로 정적 팩토리 메서드 패턴이다
- 이번 절에는 빌더 디자인 패턴을 살펴볼 것
- 이 패턴을 사용하면 복잡한 객체를 보다 쉽게 만들 수 있음
- 복잡한 객체의 예를 들기 위해 이메일 발송 시스템을 상상하자
- 실제 발송 기능은 구현하지 않고 이메일을 나타내는 클래스만 설계할 것임
- 이메일에는 다음과 같은 속성이 있을 수 있음
  - 수신자 주소(최소 1개)
  - 참조(선택사항)
  - 제목(선택사항)
  - 본문(선택사항)
  - 중요표시(선택사항)
- 이 시스템의 이메일을 다음과 같은 데이터 클래스로 표현할 수 있음
```
data class Mail_V1(
  val to: List<String>,
  val cc: List<String>?,
  val title: String?,
  val message: String?,
  val important: Boolean
)
```
> 위 코드의 마지막 매개변수 정의를 보라. 쉼표는 오타가 아님. 이를 줄 끝 쉼표(trailing comma)라고 부르며 코틀린 1.4보부터 도입된 문법임
> 덕분에 매개변수의 순서를 쉽게 바꿀 수 있다.
- 이제 관리자에게 보내는 이메일을 하나 작성해보자
```
 val mail = Mail_V1(
  listOf("manage@company",
  null,
  "Ping",
  null,
  true)
 )
```
- 참조(cc)를 null기능 타입으로 정의해서 이메일 리스트를 받거나 null을 받을 수 있도록 했다.
- 아니면 List<String> 타입으로 정의해 항상 ListOf로 인수를 전달하도록 하는 방법도 있음
- 생성자에 전달할 인수가 굉장히 많기 때문에 혼동을 방지하기 위해 주석을 달아놨다.
- 하지만 클래스를 수정해야 한다면 어떻게 될까?
- 먼저 컴파일이 되지 않을 것임
- 또한 주석도 함꼐 수정해야 함
- 즉 생성자에 인수가 너무많으면 코드가 금세 지저분해짐
- 빌더 디자인 패턴은 이런 문제를 해결하기 위해 탄생했다.
- 빌더 패턴을 사용하면 객체 생성과 인수 할당을 분리함으로써 복잡한 객체를 차근차근 만들 수 있으
- 이 절에서는 이 문제를 해결하는 여러 방법을 살펴볼 것
- 먼저 Mail 클래스를 감싸고 있는 MailBuilder 클래스를 만들어보자
```
class MailBuilder{
  private var to : List<String> = listOf()
  private var cc : List<String> = listOf()
  private var title: String = ""
  private var message: String = ""
  private var important: Boolean = false

class Mail internal constructor(
  val to: List<String>,
  val cc: List<String>?,
  val title: String?,
  val message: String?
  val important: Boolean
)
}
```
- 빌더는 생성하고자 하는 클래스와 정확히 동일한 속성을 가짐
- 하지만 모두 가변 속성이라는 점에서 다름
- 생성자에 internal 접근 제한자가 붙어 있는 것에 주목
- 이는 모듈 내의 모든 코드에서 Mail클래스에 접근할 수 있다는 뜻
- 클래스 생성을 완료하기 위해 build() 함수를 구현해보자
```
fun build() : Mail{
  if(to.isEmpty()){
    throw RuntimeException("To 속성이 비어있습니다.")
  }
  return Mail(to, cc, title, message, important)
}
```
- 각 속성을 설정할 수 있는 함수도 구현할 것
```
fun message(message: String): MailBuilder{
  this.message = message
  return this
}
// 각 속성에 대해 모두 구현해야 함
```
- 이제 다음과 같이 빌더를 이용하여 이메일을 생성할 수 있음
  - MailBuilder의 생성자를 구현한 적이 없는데 예제 코드에서는 생성자를 사용하고 있다.
  - 따로 생성잘르 구현하지 않는 이상 오류가 발생하는 코드이고, 깃허브의 코드에서도 생성자를 사용하지 않고 있기 때문에 임의로 생성자 대신 to()를 사용하는 함수로 변경했음
```
val email = MailBuilder().to(listof("hello@hello.com")).title("안녕?").build()
```
- 새로운 값을 설정한 후 현재 MailBuilder 객체를 가리키는 참조를 반환함으로써 연속해서 다른 속성을 설정하는 함수를 호출하는 메서드 사슬을 만들 수 있다
- 이 빌더패턴은 두가지 문제가 있음
  - 만들고자 하는 클래스의 속성을 빌더에도 똑같이 나열해야함
  - 속성마다 값을 설정하기 위한 함수를 선언해야함
- 코틀린에는 더 실용적인 두가지 방법이 존재하는데

### 유창한 설정자
- 이걸 사용하면 코드가 좀 더 간결해짐
- 여기선 추가적인 클래스를 만들지 않고 데이터 클래스의 생성자에서 필수적인 필드만 입력으로 받을 것임
- 필수적이지 않은 나머지 필드는 비공개로 선언하고 각각에 대해 설정자를 구현할 것
```
data class Mail_V2 (
  val to: List<String>,
  private var _message: String? = null,
  private var _cc : List<String>? = null,
  private var _title: String? = null,
  private val _important: Boolean? = null
){
  fun message(message: String) = apply {
    _message = message
  }
  //다른 모든 필드에 대해서 같은 방법으로 구현함
}
```
> 비공개 변수의 이름에 밑줄 문자를 사용하는 것은 코틀린에서 일반적인 관례임.
> 이렇게 하면 this.message = message 와 같이 작성할 필요도 없고, message = message라고 작성하는 실수도 막을 수 있음

- 이 예제 코드에서는 apply 함수를 사용함
- 이 함수는 모든 코틀린 객체를 대상으로 호출할 수 있는 시야 지정 함수 중 하나
- 시야 지정 함수에 대한 자세한 내용은 9장에서 다룰 것
- apply함수는 주어진 블록을 실행한 뒤 객체의 참졸르 반환함
- 즉 이전 예제에서 다음과 같이 구현했던 설정자 코드의 짧은 버전임
```
fun message(message: String):MailBuilder{
  this.message = message
  return this
}
```
- apply 함수를 사용해도 API는 동일하므로 다음과 같이 사용할 수 있음
```
val mailV2 = Mail_V2(listOf("manager@company.com")).message("안녕")
```
- 그러나 아예 설정자를 구현하지 않는 방법도 있음.
- 위에서 언급한 apply() 함수를 객체 자체에 사용하는 것
- apply()함수는 코틀린의 모든 객체에 존재하는 확장함수임
- 다만 이 방법은 선택적 필드가 값이 아닌 변수로 선언돼 있을때만 가능
- 이 방법 사용 시 이메일 객체를 다음과 같이 생성할 수 있음
```
val mail = Mail_V2("hello@gamil.com").apply{
  message = "어떤 메시지"
  title = "Apply"
}
```
- 괜찮은 방법이다. 작성해야 하는 코드도 많이 줄었다.
- 하지만 이 방법에도 몇가지 단점이 있다.
  - 선택적 인수를 모두 가변 필드로 선언해야 함. 그러나 가능하다면 가변 필드보다는 스레드 안전하며 값을 추적하기 용이한 불변 필드를 사용하는 것이 나음
  - 모든 선택적 인수가 null값을 가질 수 있음. null안전성 탓에 변수에 접근할 때마다 값이 Null인지를 확인해야함
  - 문법이 너무 장황함. 각 필드에 대해 똑같은 패턴을 계속 반복해야함
- 이 문제를 해결하는 방법은 기본 인수를 사용하는 것이다.

### 기본인수
- 코틀린에서는 생성자의 함수의 매개변수에 기본값을 설정할 수 있음
```
data class Mail_V3(
  val to : List<String>
  val cc : List<String> = listOf()
  val title : String = ""
  val message: String = ""
  val important: Boolean = false
)
```
- 타입 뒤에 = 연산자를 사용해 기본 인수로 설정함
- 이렇게 하면 생성자가 모든 안수를 받을 수 있지만 모든 인수를 항상 필수적으로 전달할 필요는 없게 됨
- 따라서 본문이 없는 이메일을 생성하고 싶다면 다음과 같이 할 수 있음
```
val mail = Mail_V3(listOf("manage@company.com"), listOf(), "안녕")
```
- 하지만 참조 목록에 아무도 없다는 것을 나타내기 위해 빈 리스트를 전달해야 하는 것에 주목하라. 다소 불편함
- 만약 중요 플래그만 설정해서 이메일을 보내고 싶다면 어떻게 되나?
- 유창항 설정질르 사용하면 순서는 따질 필요가 없어 매우 편리했음
- 비슷한 목적으로 코틀린은 명명 인수라는 기능을 제공함
```
val mail = Mail_V3(title = "안녕", message = "잘 지내니?", to = listOf("my@dear.cat"))
```
- 기본 매개변수와 명명 인수를 함꼐 사용하면 코틀린에서 복잡한 객체를 사용하는 것이 한결 쉬워짐
- 따라서 코틀린에서 빌더 디자인 패턴을 사용할 일이 없어진다.

## 프로토 타임 패턴
- 프로토타입 디자인 패턴은 유사하면서도 조금 다른 객체를 그때그때 목적에 맞게 생성하기 위해 사용됨
- 이게 뭔뜻이냐?
- 사용자와 권한을 관리하는 시스템을 만든다고 상상해보자.
- 사용자를 나타내는 데이터 클래스는 다음과 같다
```
data class User(
  val name: String,
  val role: Role,
  val permissions: Set<String>,
) {
  fun hasPermission(permission: String) = permission in permissions
}
```
- 각 사용자는 하나의 역할을 가져야 하며 각 역할은 여러 권한을 갖는다
- 역할은 다음과 같이 enum 클래스로 정의할 수 있음
```
enum class Role {
  ADMIN,
  SUPER_ADMIN,
  REGULAR_USER
}
```
- enum 클래스는 상수의 모음을 표현하기 위해 사용됨
- 역할은 문자열 등 다른 타입으로도 표현할 수 있지만 enum 클래스를 사용하는 쪽이 편하다.
- 해당 객체가 존재하는지 컴파일 타임에 검사해주기 때문
- 새로운 사용자를 만들 땐 동일한 역할을 갖는 다른 사용자와 비슷한 권한을 부여함
```
// 실제 어플리케이션에서는 사용자 데이터베이스에 해당
val allUsers = mutableListOf<User>()

fun createUser(name: String, role : Role){
  for(u in allUsers){
    if(u.role == role) {
      allUser += User(name, role, u.permissions)
      return
    }
  }
  // 같은 권한을 갖는 다른 사용자가 존재하지 않는 경우 처리
}
```
- User 클래스에 tasks라는 새로운 필드를 추가해야 한다고 하자
```
data class User (
  val name: String,
  val role: Role,
  val permissions: Set<String>,
  val tasks: List<String>
)
```
- 이제 createUser함수는 더 이상 컴파일 되지 않는다.
- 신규 필드의 값을 새 인스턴스에 복사하도록 코드를 수정해야함
```
allUsers += User(name, role, u.permissions, u.tasks)
```
- User 클래스가 바뀔 때 마다 이런식으로 코드를 수정해줘야 할 것임
- 더 큰 문제가 있는데, 가령 요구사항이 추가돼서 permissions 속성을 비공개로 바꿔야 한다면 어떻게 되나?
```
data class User(
  val name: String,
  val role: Role,
  private val permissions: Set<String>,
  val tasks: List<String>,
){
  ...
}
```
- 컴파일 오류가 발생할 것이고, 또다시 코드를 수정해야 함
- 이렇게 거듭 코드를 변경해야 한다는 것은 다른 접근 방법이 필요하다는 뚜렷한 신호임

### 프로토타입에서 시작하기
- 프로토타입의 핵심 아이디어는 객체를 쉽게 복사할 수 있도록 하는 것.
- 적어도 다음의 두가지 경우에 프로토 타입 패턴이 필요하다.
  - 객체 생성에 많은 비용이 드는 경우(예를 들어 객체 생성 시 데이터베이스에서 자료를 조회해야 하는 경우)
  - 비슷하지만 조금씩 다른 객체를 생성하느라 비슷한 코드를 매번 반복하고 싶지 않은 경우
> 더 깊이 들어가면 프로토타입 패턴이 필요한 다른 이유도 있음
> 가령 자바스크립트에서는 클래스 없이 객체와 비슷한 동작을 구현하기 위해 프로토타입을 사용
- 자바의 엉터리같은 clone() 메서드가 다행히도 코틀린에서는 고쳐짐
- 코틀린에서 모든 데이터클래스는 copy()메서드를 가짐
- 이 메서드는 다른 데이터 클래스의 인스턴스를 받아 복제본을 생성하며, 원한다면 그 과저에서 속성을 변경할 수도 있다.