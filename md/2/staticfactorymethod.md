## 정적 팩토리 메서드
- 팩토리 메서드 패턴과 이름이 비슷해서 자주 햇갈리는 디자인 패턴이 있음
- GoF의 책에도 등장하는 정적 팩토리 메서드 디자인 패턴이다.
- 정적 팩토리 메서드 디자인 패턴은 이펙티브 자바에서 좀 유명해짐(나중에 정리진행)
- 이 패턴을 이해하기 위해 자바의 표준 라이브러리에 있는 valueOf() 메서드를 보면 자바에는 문자열로부터 long 객체(64비트 정수)를 만드는 방법이 두가지가 있음
```
Long l1 = new Long("1"); 
Long l2 = Long.valueOf("1");
```
- 생성자나 valueOf()메서드 모두 문자열을 입력으로 받아 Long을 출력으로 만들어 냄
- 그러면 간단한 생성자 대신 정적 팩토리 메서드 디자인 패턴을 사용하는 이유는 뭘까

### 팩토리 메서드 디자인 패턴의 장점
- 다양한 생성자에 명시적인 이름을 붙일 수 있음.
  - 클래스에 생성자가 많은 경우에 특히 유용
- 일반적으로 생성자에서는 예외가 발생하지 않으리라는 기대가 있음
  - 그러나 클래스 인스턴스 생성이 절대 실패하지 않는 것은 아님
  - 예외가 불가피하다면 생성자보다는 일반적으로 메서드에서 발생하는 편이 훨씬 낫다.
- 생성자에 기대하는 것이 한가지 있다면 빠르다는 것
  - 그러나 생성하는 데에 시간이 오래 걸릴수밖에 없는 객체도 있다.
  - 그런 경우는 생성자 대신 정적 팩토리 메서드를 고려할 것
- 이 세가지는 대체로 스타일 측면의 장점임 하지만 정적 팩토리 메서드에는 기술적 장점도 있다.

### 캐시
- 정적 팩토리 메서드를 사용하면 캐시를 적용할 수 있음
- 실제로 Long도 캐시를 함
- valueOf()함수는 모든 값에 대해서 항상 새 객체를 반환하는 대신 이미 파싱한 적이 있는 값인지 확인함
- 만약 파싱한 적이 있다면 캐시된 객체로 반환
- 같은 값으로 정적 팩토리 메서드를 반복 호출하면 생성자를 사용하는 것에 비해 가비지 컬레렉션을 해야 하는 객체가 덜 생김

### 하위 클래스 생성
- 생성자를 호출하면 항상 그 클래스의 인스턴스를 얻음.
- 그러나 정적 팩토리 메서드에는 그런 제한이 없음
- 해당 크래스의 인스턴스를 생성할 수 있지만, 그 하위 클래스의 인스턴스를 만들어 낼 수 있다
- 코틀린으로 정적 팩토리 메서드를 구현하는 법을 먼저 살펴보고 나서 이 부분을 더 구체적으로 설명한다

### 코틀린에서 정적 팩토리 메서드 구현
- 2장 앞부분에서 싱글톤을 다루면서 object 키워드를 소개했다.
- 이번에는 Object 키워드를 이용해 동반객체를 만드는 방법을 살펴보자
- 자바에서는 정책 팩토리 메서드는 static으로 선언한다.
- 그러나 코틀린에는 그런 키워드가 없다.
- 대신 인스턴스에 속하지 않는 메서드는 동반 객체 내부에 선언할 수 있음
```
class Server(port : Long){
  init{
    println("$port 포트에서 서버가 시작됨")
  }
  companion object{
   // 동반객체
   fun withPort(port: Long) = Server(port) 
  }
}
```
> 동반 객체는 이름을 가질 수 있다.
> 예를들어 companion object parser로 선언할 수 있음
> 그러나 이 이름은 동반 객체의 목적이 무엇인지 조금 더 명확하게 알려주는 것 이상의 역할은 하지 않음

- 객체 선언 앞에 붙은 companion 키워드에 주목
- 또한 싱글톤 패턴과 달리 객체를 패키지 수준에 선언하지 않고 클래스 내부에 선언함
- 이 객체는 자체 메서드를 가진다. 그래서 뭐가 좋은 것인지 궁금할 수도 있다.
- 자바의 성적 메서드와 마찬가지로 동반 객체는 해당 클래스에 처음 접근할 때 게으르게 생성됨
```
Server.withPort(8080) // 8080포트에서 서버가 시작됨
```
> 하나의 클래스에는 1개의 동반 객체만 존재할 수 있음.

- 인스턴스가 정적 팩토리 메서드를 통해서만 생성되기를 원할 때도 있다.
- 그럴 땐 객체의 기본 생성자를 private으로 선언하면 됨
- 예제
```
class Server private constructor(port : Long){
  ...
}
```
- 이제 이 클래스는 정적 팩토리 메서드를 통해서만 인스턴스화가 가능
```
val server = Server(8080) // 실패
val server = Server.withPort(8080) // 성공
```