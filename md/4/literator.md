## 반복자 패턴
- 3장에서 합성 패턴을 배우며 합성 패턴이 그 자체로는 다소 불완전하다는 사실을 언급함
- 이제 나머지 반쪽을 찾을 시간임
- 3장 예제코드 중 분대 클래스가 있는데 그 안에는 트루퍼 또는 다른 분대가 속할 수 있었다.
```
var platoon = Squad(
    Trooper(),
    Squad(
        Trooper(),
    ),
    Trooper(),
    Squad(
        Trooper(),
        Trooper(),
    ),
    Trooper()
)
```
- 이 소대에는 총 6명의 트루퍼가 소속되어 있음
- 1장에서 배웠던 for-in문을 사용해 소대에 소속된 모든 트루퍼를 출력할 수 있다면 좋을 것
- 다음과 같이 코드를 작성하고 어떤 일이 일어나는지 보자
```
for (trooper in platoon) {
    println(trooper)
}
```
- 코드는 컴파일되지 않지만 코틀린 컴파일러에서 다음과 같은 유용한 힌트를 얻을 수 있다
> For loop range must have an iterator method
- for-in 구문에 사용하는 범위는 반복자 메서드를 가져야 하고 친절히 안내하고 있음
- 이를 따라 메서드를 구현하기 전에 지금 마주하고 있는 문제가 무엇인지를 간단히 살펴본다
- 합성 패턴으로 만든 소대 객체의 구조는 평면적이지 않다.
- 즉 소대에 포함된 객체가 또 다른 객체를 담고 있을 수 있음
- 하지만 이런 경우에도 복잡성을 추상화시키고 소대를 그냥 트루퍼 객체의 리스트처럼 사용하고 싶을 수 있음
- 이게 반복자 lterator패턴이 하는 일임
- 즉 복잡한 자료 구조를 단순한 리스트 형태로 평면화 시키는 것
- 어떤 순서로 자료구조를 순회하며 어떤 원소를 건너 뛸지는 반복자가 결정한다
- for-in 반복문에서 squad객체를 사용하려면 Iterator()라는 특수 함수를 구현해야 함
- 이 함수는 특수 함수이기 대문에 operator키워드를 사용해야 함
```
operator fun iterator() = ...
```
- 이 함수는 Iterator<T> 인터페이스를 구현하는 익명 객체를 반환함
```
operator fun iterator() = object: Iterator<Trooper> {
    override fun hasNext() : Boolean {
        // 반복할 원소가 남아 있는가
    }
    override fun next(): Trooper {
        // 다음 트루퍼 객체를 반환
    }
}
```
- 코틀린에서 제네릭을 사용하는 것을 또 볼수 있다.
- Iterator<Trooper>타입은 이를 구현하는 객치의 next()함수가 항상 Trooper 타입의 객체를 반환한다는 것을 의미함
- 반복문에서 모든 원소를 순회하기 위해서는 2개의 메서드를 구현해야 함
- 하나는 다음 원소를 가져오는 메서드
- 다른 하나는 반복문을 언제까지 실행할지 알려 주는 메서드
- 다음 세 단계를 통해 메서드를 구현해보자

1. 먼저 반복자의 상태가 필요함. 이 상태에는 마지막에 반환한 원소를 저장함
```
operator fun iterator() = oebject: Iterator<Trooper>{
    private var i = 0
    // 다른 코드를 여기에 작성
}
```
2. 다음으로는 언제 반복문을 멈춰야 할지 알려줘야 함. 간단한 경우에는 내부 자료 구조의 크기가 동일함
```
override fun hasNext(): {
    return i < units.size
}
```
- 하지만 경계에 있는 몇몇 경우까지  고려하면 조금 더 복잡해짐
- 완전한 구현은 책의 깃허브 저장소를 참조

3. 마지막으로 어떤 원소를 반환할 지 알아야 함. 간단한 경우에는 그냥 현재 원소를 반환하고 다음 원소로 이동함
```
override fun next() = units[i++]
```
- Squad와 같은 경우에는 더 복잡함.
- Squad객체가 또 다른 Squad객체를 가질 수 있기 때문
- 여기서도 전체 구현은 깃 저장소에서 확인한다
- 떄로는 함수의 인수로 반복자를 받는것도 가능

```
fun <T> printAnything(iter: Iterator<T>) {
    while(iter.hasNext()) {
        println(iter.next())
    }
}
```
- 이 함수는 반복자를 제공하는 모든 자료 구조에 대해 반복을 수행할 수 있음
- 이 함수는 또한 코틀린에서 제네릭 함수를 사용하는 예를 보여줌
- 함수 이름 앞에 <T>가 붙는다는 것을 확인할것
- 새로운 자료 구조를 발명할 일이 없는 보통의 개발자가 반복자를 구현할 일은 별로 없다.
- 하지만 반복문을 사용할 때 어떤 일이 벌어지는지는 알고 있어야 함
- 다음 절에서는 유한 상태 기계를 효율적으로 설계하는 방법을 알아볼것