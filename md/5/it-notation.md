## it 표기법
- 일반적으로 함수형 프로그래밍에서는 함수를 작고 간단하게 만들어야 함
- 함수가 간단할수록 이해하기 쉬워지고, 그만큼 다른 곳에서 재사용할 기회도 많아지기 때문
- 코드 재사용을 쉽게 만드는 것은 코틀린의 기본 원칙 중 하나
- 앞의 예제 코드를 다시 살펴보면, 변수 d의 타입을 명시하지 않음
- 다른 함수 선언에서와 같이 콜론을 사용해서 타입을 명시할 수도 이;ㅆ었음

```
dwarfs.forEach{
    d: String -> println(d)
}
```
- 그러나 일반적으로 컴파일러가 제네릭 타입에서 변수의 타입을 추론해 낼 수 있기 때문에 굳이 명시적으로 표현할 필요가 없는 것
- 즉 dwarfs가 List<String> 타입이므로 d는 자연스럽게 String 타입이 됨
- 이처럼 짧은 함수를 작성할 때는 인수 타입만 생략할 수 있는 것이 아님
- 람다 함수에 인수가 하나 뿐이라면 암시적 이름을 사용할 수 있음
- 이 경우에 암시적 이름은it이다.

```
dwarfs.forEach{
    println(it)
}
```
- 하나의 매개변수에 대해 하나의 함수를 호출해야 하는 경우에는 함수 참조를 사용할 수도 있음
- 4장에서 전략 패턴을 배울 때도 함수 참조를 어떻게 사용하는지 살펴봄
```
dwarfs.forEach(::println)
```
- 이후의 예제에서는 가장 짧은 표기법을 사용할 것
- 일반적으로 람다 함수 안에 다른 람다 함수를 중첩하는 경우에는 긴 표기법을 사용하는 것이 좋음
- 그런 경우에는 간 결합보다 매개변수에 제대로된 이름을 붙이는 것이 더 중요해지기 때문

### 클로저
- 객체지향 패러다임에선느 상태를 항상 객체에 저장함
- 그러나 함수형 프로그래밍에서는 꼭 그렇지만은 않음
```
fun counter(): ()-> Int {
    var i = 0;
    return { i++}
}
```
- 반환형에서 보다시피 counter 함수는 분명히 고차함수임
- 0개의 인수를 받아서 정수를 반환하는 함수를 반환함
- 지금까지 배운대로 이 함수를 변수에 저장하고 여러번 호출한다.
```
val next = counter()
println(next())
println(next())
println(next())
```
- 함수가 상태를 갖는 것을 볼 수 있다.
- 이 경우에는 호출할 때마다 1씩 증가하는 값이 함수의 상태임
- 객체를 사용하지 않고도 상태를 표현할 수 있는 것
- 이를 클로저라고 함
- 이 람다 함수는 선언된 위치에서 보이는 모든 지역 변수에 접근할 수 있음
- 그리고 람다 함수에 대한 참조를 들고 있는 동안은 이 지역 변수 상태도 유지됨
- 클로저는 함수형 프로그래밍에서 사용할 수 있는 유용한 도구 중 하나
- 함수가 상태를 갖도록 하려면 고작 함수 하나 때문에 클래스를 정의해야 하는 경우가 종종 생김
- 하지만 클로저를 사용하면 클래스를 만들지 않고도 함수가 상태를 갖도록 할 수 있음

### 순수 함수
- 순수함수란 부수효과가 전혀 없는 함수
- 부수효과란 외부 상태를 조회하거나 변경하는 모든 것을 말함
- 외부 상태는 지역 변수가 아닌 변수(클로저로 보이는 변수도 지역 변수로 볼 수 없음)
- 모든 종류의 IO(파일이나 각종 네트워크 위치에서 수행하는 읽기/쓰기 작업)일 수 있음

>IO라는 용어가 익숙하지 않은 독자를 위해 설명을 덧붙이자면 IO는 input/output의 약어로 프로그램 외부에서 일어나는 모든 상호작용을 말함
> 예를들어 파일을 기록하거나 네트워크에서 읽는 것은 IO작업임
- 예를들어 클로저 절에서 설명한 람다 함수는 '순수하지' 않다. 여러번 호출하면 같은 입력에 대해서 매번 다른 출력을 반환하기 때문
- 순수하지 않은 함수는 일반적으로 테스트도 어렵고 동작을 이해하기도 힘듬
- 실행 순서나 네트워크 문제 등 통제하기 어려운 요소에 따라 함수의 반환값이 달라지기 때문
- 한가지 기억해야 할 부분은 로깅이나 콘솔 출력도 IO를 수행하기 때문에 같은 종류의 문제를 일으킨다는 것
- 다음 함수를 본다
```
fun sayHello() = println("안녕")
```
- 이 경우에 '안녕'이 잘 출력됐다는 것을 어떻게 확인할 수 있을까?
- 보기보다 쉽지 않은 문제임
- 표준 출력(일반적으로 사용하는 콘솔 출력)의 상태를 확인해서 출력 결과를 알아내야 햐기 때문
- 이번에는 다음 함수와 비교해본다.
```
fun hello() = "안녕"
```
- 이 함수는 아무런 부수 효과를 일으키지 않기 때문에 훨씬 쉽게 테스트할 수 있음
```
fun testHello(): Boolean {
    return "안녕" == hello()
}
```
- 이 hello()함수는 다소 무의미해 보일 수 있ㅇㅁ
- 하지만 그게 순수 함수의 속성 중 하나
- 함수의 실행 결과를 미리 알고 있다면 함수를 호출하지 않고 그 결과값을 직접 쓸 수 있음
- 이것을 참조 투명성이라 부르기도 한다
- 코틀린의 모든 함수가 순수 함수인 것은 아님
```
fun <T> removeFirst(list: MutableList<T>):T {
    return list.removeAt(0)
}
```
- 같은 리스트에 대해서 이 함수를 두 번 호출하면 다른 값을 반환할 것
```
val list = mutableListOf(1, 2, 3)

println(removeFirst(list))
println(removeFirst(list))
```
- 이번에는 다음 함수와 비교해본다
```
fun<T> withoutFirst(list: List<T>): T {
    return ArrayList(list).removeAt(0)
}
```
- 이 함수는 완전히 예측 가능하다. 몇번을 호출하든 그 결과는 모두 같음
```
val list = mutableListOf(1,2,3)

println(withoutFirst(list)) // 1출력
println(withoutFirst(list)) // 이번에도 1 출력
```
- 보다시피 이경우에는 불변 인터페이스인 List<T>를 사용함으로 입력 데이터를 변경하지 못하게 함
- 순수 함수를 이전 절에서 배운 불변 값과 함께 사용시 함수의 반환값을 예측할 수 없음
- 그러면 테스트가 쉬워지고 알고리듬 병렬화도 가능해짐
- 순수 함수를 사용하는 시스템은 분석하기 쉬움
- 외부 요소에 따라 동작이 달라지지 않고 보이는대로 동작하기 때문

### 커리
- 커리는 인수 여러개를 받는 함수를 단일 인수로 받는 함수의 연쇄  호출로 변환하는 것을 말함
- 예제로 뭔뜻인지 보다
```
fun subtrac(x: Int, y: Int) : {
    return x - y
}
println(substract(50, 8))
```
- 이 함수는 2개의 인수를 받아서 두 수의 차를 반환함
- 그런데 어떤 언어에서도 이 함수를 다음과 같이 호출할 수 있음
```
substract(50)(8)
```
- 이것이 함수에 커리를 작용해서 호출한 것
- 커리는 입력 인수가 여러개(예제에서는 2개)인 함수를 인수가 하나인 여러개의 함수로 바꿔줌\
- 코틀린에서 커리를 적용하는 방법을 살펴본다
- 함수에서 다른 함수를 반환하는 방법은 이미 배움
```
fun subtract(x : Int): (Int) -> Int {
    return fun (y : Int) : Int {
        return x - y
    }
}
```
- 이 코드를 더 짧게 쓰면 다음과 같음
```
fun subtract(x: Int) = fun(y: Int): Int{
    return x - y
}
```
- 이 코드에서는 반환형을 명시하지 않고 return 키워드도 사용하지 않는다
- 대신 단일식 문법을 사용해서 익명함수를 반환했음
- 다음과 같이 더 짫게 줄여쓸 수 있음
```
fun subtrack(x: Int) = {y: Int -> x - y}
```
- 이제 익명 함수가 람다 함수가 됐고 람다 함수의 반환형도 자동으로 추론됨
- 커리는 그 자체로는 그다지 유용하지 않지만 어쨌든 흥미로운 개념임
- 또한 구직 중인 자바스크립트 개발자라면 커리를 이해해야 함
- 단골 인터뷰 질문이기 떄문
- 실제 로그를 기록할 때 커리를 사용핳기도 함 log함수는 보통 다음과 같이 생김
```
enum class LogLevel {
    ERROR, WARNING, INFO
}
fun log(level : LogLevel, message: String) = 
    println("$level: $message")
```
- 다음과 같이 함수를 변수에 저장해놓으면 로그 수준을 고정할 수 있음
```
val errorLog = fun(message: String) {
    log(LogLevel.ERROR, message)
}
```
- log함수보다 errorLog함수가 더 사용하기 쉬움, 인수를 하나만 받기 때문
- 그렇다면 이런 생각이 들 수 있음
- 모든 로그 수준에 대해 로거를 미리 만들어 놓기는 싫다면 어떻게 하나
- 그럴 때 커리를 사용, 이 코드를 커리 버전으로 작성하면 다음과 같음
```
fun createLogger (level: LogLevel): (String) -> Unit {
    return {
        message: String -> log(level, message)
    }
}
```
- 이제 사용자가 편하게 로그 함수를 만들 수 있음
```
val infoLogger = createLogger(LogLevel.INFO)
infoLogger("로그 메시지")
```
- 사실 이느느 2장에서 배웠던 팩토리 패턴과 비슷함
- 다시 한번 강조하지만 현대적 언어의 힘을 빌리면 적은 개수의 클래스를 갖고도 같은 기능을 구현할 수 있음

### 메모이제이션
- 어떤 함수와 같은 입력에 대해서 항상 같은 출력을 낸다면 입력마다 출력을 저장함으로써 함수의 결과를 캐시하는 것도 어렵지 않음
- 이 기법을 메모이제이션 이라고 함
- 개발하는 시스템이나 해결하려는 문제가 무엇이든 간에 일반적으로 같은 계산을 여러번 반복하는 일은 최대한 피해야 함
- 예를 들어 여러개의 정수 세트를 받아 각 세트의 총합을 출력하는 함수를 만든다 한다
```
val input = listOf(
    setOf(1,2,3),
    setOf(3,1,2),
    setOf(2,3,1),
    setOf(4,5,6)
)
```
- 처음 3개의 입력은 사실상 같음 원소가 나열된 순서만 다르기 때문에 더하기를 세번하는건 낭비
- 함계를 계산하는 함수는 다음과 같이 순수 함수로 작성할 수 있음
```
fun sum(number: Set<Int>): Double {
    return numbers.sumByDouble { it.toDouble()}
}
```
- 이 함수는 어떠한 외부 상태에도 의존하지 않으며 외부 상태를 변경하지도 않음
- 따라서 어떤 입력에 대해 이 함수를 호출한 적이 있다면 같은 입력에 대해서는 다시 함수를 호출하지 않고 이전 반환값을 사용해도 무방함
- 각 입력에 대한 계산 결과는 다음과 같이 가변 맵에 저장할 수 있음
```
val resultsCache = mutableMapOf<Set<Int>, Double>()
```
- 고차 함수를 사용하면 따로 클래스를 만들지 않고도 캐시를 적용할 수 있음
```
fun summarizer():(Set<Int>) -> Double {
    val resultsCache = mutableMapOf<Set<Int>, Double>()

    return {
        number: Set<Int> -> resultsCache.computeIfAbsent(numbers, ::sum)
    }
}
```
- 캐시되지 않은 입력에 대해서 값을 계산할 때는 sum() 함수를 사용하라고 computeIfAbsent 함수에 지시하기 위해 메서드 참조 연산자(::)를 사용함
- sum()은 순수 함수이지만 summerizer()는 아님
- summerizer() 함수는 같은 입력에 대해서도 다른 식으로 동작할 것임
- 하지만 이 경우에는 그것을 원하는 것
- 앞서 제시한 입력에 대해서 다음 코드를 실행하면 합계 계산은 딱 두번만 이루어질 것
```
val sermmarize = summarizer()
input.forEach{
    println(summarizer(it))
}
```
- 불변 객체, 순수 함수, 클로저를 조합해서 구현한 메모제이션은 성능 최적화를 위한 강력한 도구가 됨
- 단 기억하라 세상에 공짜는 없다. CPU성능을 얻는다면 잃는것도 있음, 메모리 공간임
- 각 경우에 어떤 자원이 더 값비싼지는 개발자가 알아서 판단할 일임
