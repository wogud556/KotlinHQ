## it 표기법
- 일반적으로 함수형 프로그래밍에서는 함수를 작고 간단하게 만들어야 함
- 함수가 간단할수록 이해하기 쉬워지고, 그만큼 다른 곳에서 재사용할 기회도 많아지기 때문
- 코드 재사용을 쉽게 만드는 것은 코틀린의 기본 원칙 중 하나
- 앞의 예제 코드를 다시 살펴보면, 변수 d의 타입을 명시하지 않음
- 다른 함수 선언에서와 같이 콜론을 사용해서 타입을 명시할 수도 이;ㅆ었음

```
dwarfs.forEach{
    d: String -> println(d)
}
```
- 그러나 일반적으로 컴파일러가 제네릭 타입에서 변수의 타입을 추론해 낼 수 있기 때문에 굳이 명시적으로 표현할 필요가 없는 것
- 즉 dwarfs가 List<String> 타입이므로 d는 자연스럽게 String 타입이 됨
- 이처럼 짧은 함수를 작성할 때는 인수 타입만 생략할 수 있는 것이 아님
- 람다 함수에 인수가 하나 뿐이라면 암시적 이름을 사용할 수 있음
- 이 경우에 암시적 이름은it이다.

```
dwarfs.forEach{
    println(it)
}
```
- 하나의 매개변수에 대해 하나의 함수를 호출해야 하는 경우에는 함수 참조를 사용할 수도 있음
- 4장에서 전략 패턴을 배울 때도 함수 참조를 어떻게 사용하는지 살펴봄
```
dwarfs.forEach(::println)
```
- 이후의 예제에서는 가장 짧은 표기법을 사용할 것
- 일반적으로 람다 함수 안에 다른 람다 함수를 중첩하는 경우에는 긴 표기법을 사용하는 것이 좋음
- 그런 경우에는 간 결합보다 매개변수에 제대로된 이름을 붙이는 것이 더 중요해지기 때문

### 클로저
- 객체지향 패러다임에선느 상태를 항상 객체에 저장함
- 그러나 함수형 프로그래밍에서는 꼭 그렇지만은 않음
```
fun counter(): ()-> Int {
    var i = 0;
    return { i++}
}
```
- 반환형에서 보다시피 counter 함수는 분명히 고차함수임
- 0개의 인수를 받아서 정수를 반환하는 함수를 반환함
- 지금까지 배운대로 이 함수를 변수에 저장하고 여러번 호출한다.
```
val next = counter()
println(next())
println(next())
println(next())
```
- 함수가 상태를 갖는 것을 볼 수 있다.
- 이 경우에는 호출할 때마다 1씩 증가하는 값이 함수의 상태임
- 객체를 사용하지 않고도 상태를 표현할 수 있는 것
- 이를 클로저라고 함
- 이 람다 함수는 선언된 위치에서 보이는 모든 지역 변수에 접근할 수 있음
- 그리고 람다 함수에 대한 참조를 들고 있는 동안은 이 지역 변수 상태도 유지됨
- 클로저는 함수형 프로그래밍에서 사용할 수 있는 유용한 도구 중 하나
- 함수가 상태를 갖도록 하려면 고작 함수 하나 때문에 클래스를 정의해야 하는 경우가 종종 생김
- 하지만 클로저를 사용하면 클래스를 만들지 않고도 함수가 상태를 갖도록 할 수 있음

### 순수 함수
- 순수함수란 부수효과가 전혀 없는 함수
- 부수효과란 외부 상태를 조회하거나 변경하는 모든 것을 말함
- 외부 상태는 지역 변수가 아닌 변수(클로저로 보이는 변수도 지역 변수로 볼 수 없음)
- 모든 종류의 IO(파일이나 각종 네트워크 위치에서 수행하는 읽기/쓰기 작업)일 수 있음

>IO라는 용어가 익숙하지 않은 독자를 위해 설명을 덧붙이자면 IO는 input/output의 약어로 프로그램 외부에서 일어나는 모든 상호작용을 말함
> 예를들어 파일을 기록하거나 네트워크에서 읽는 것은 IO작업임
- 예를들어 클로저 절에서 설명한 람다 함수는 '순수하지' 않다. 여러번 호출하면 같은 입력에 대해서 매번 다른 출력을 반환하기 때문
- 순수하지 않은 함수는 일반적으로 테스트도 어렵고 동작을 이해하기도 힘듬
- 실행 순서나 네트워크 문제 등 통제하기 어려운 요소에 따라 함수의 반환값이 달라지기 때문
- 한가지 기억해야 할 부분은 로깅이나 콘솔 출력도 IO를 수행하기 때문에 같은 종류의 문제를 일으킨다는 것
- 다음 함수를 본다
```
fun sayHello() = println("안녕")
```
- 이 경우에 '안녕'이 잘 출력됐다는 것을 어떻게 확인할 수 있을까?
- 보기보다 쉽지 않은 문제임
- 표준 출력(일반적으로 사용하는 콘솔 출력)의 상태를 확인해서 출력 결과를 알아내야 햐기 때문
- 이번에는 다음 함수와 비교해본다.
```
fun hello() = "안녕"
```
- 이 함수는 아무런 부수 효과를 일으키지 않기 때문에 훨씬 쉽게 테스트할 수 있음
```
fun testHello(): Boolean {
    return "안녕" == hello()
}
```
- 이 hello()함수는 다소 무의미해 보일 수 있ㅇㅁ
- 하지만 그게 순수 함수의 속성 중 하나
- 함수의 실행 결과를 미리 알고 있다면 함수를 호출하지 않고 그 결과값을 직접 쓸 수 있음
- 이것을 참조 투명성이라 부르기도 한다
- 코틀린의 모든 함수가 순수 함수인 것은 아님
```
fun <T> removeFirst(list: MutableList<T>):T {
    return list.removeAt(0)
}
```
- 같은 리스트에 대해서 이 함수를 두 번 호출하면 다른 값을 반환할 것
```
val list = mutableListOf(1, 2, 3)

println(removeFirst(list))
println(removeFirst(list))
```
- 이번에는 다음 함수와 비교해본다
```
fun<T> withoutFirst(list: List<T>): T {
    return ArrayList(list).removeAt(0)
}
```
- 이 함수는 완전히 예측 가능하다. 몇번을 호출하든 그 결과는 모두 같음
```
val list = mutableListOf(1,2,3)

println(withoutFirst(list)) // 1출력
println(withoutFirst(list)) // 이번에도 1 출력
```
- 보다시피 이경우에는 불변 인터페이스인 List<T>를 사용함으로 입력 데이터를 변경하지 못하게 함
- 순수 함수를 이전 절에서 배운 불변 값과 함께 사용시 함수의 반환값을 예측할 수 없음
- 그러면 테스트가 쉬워지고 알고리듬 병렬화도 가능해짐
- 순수 함수를 사용하는 시스템은 분석하기 쉬움
- 외부 요소에 따라 동작이 달라지지 않고 보이는대로 동작하기 때문