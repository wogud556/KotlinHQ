## 코루틴
- 코틀린은 자바의 스레드 모델에 대해 코루틴 모델을 제공함
- 코루틴은 가벼운 스레드라고 생각하면 됨
- 코루틴이 스레드에 비해 어떤 장점을 갖는지는 곧 살펴볼 것
- 먼저 알아야 할 점은 코루틴이 언어의 내장 기능이 아니라는 것, 단지 젯브레인스에서 제공하는 하나의 라이브러리일 뿐
- 따라서 코루틴을 사용하려면 그래들 설정 파일(gradle.kts)에 이를 명시해줘야함
```
dependencies {
    ...
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.1")
}
```
- 코루틴 최신 라이브러리를 사용할 것

### 코루틴 시작하기
- 코틀린에서 새로운 스레드를 시작하는 방법은 6장의 '스레드 심화' 절에서 살펴봄
- 이제 새로운 코루틴을 시작한다
- 스레드에서 사용했던 것과 거의 같은 예제를 작성할 것
- 각 코루틴은 어떤 변수의 값을 증가 시킨 뒤 IO작업을 모사하기 위해 잠깐 잠들었다가 깨어나서 다시 변수의 값을 증가시킴
```
val latch = CountDownLatch(10_000)
val c = AtomicInteger()
val start = System.currentTimeMillis()
for (i in 1..10_000) {
    GlobalScope.launch {
        c.incrementAndGet()
        delay(100)
        c.incrementAndGet()
        latch.countDown()
    }
}
latch.await(10, TimeUnit.SECONDS)

println("${c.get()/2}개의 코루틴을 ${System.currentTimeMillis() - start} 밀리초 동안 수행")
```
#### 코루틴 사용법
- 코루틴을 시작하는 첫 번째 방법은 launch()함수를 사용하는 것
- 다시한번 강조하지만 이건 코틀린의 문법이 아니라 하나의 함수일 뿐이다
- 이 코드에서 눈여겨 봐야 하는 또 하나는 delay() 함수 호출임
- 데이터베이스나 네트워크 위치에서 자료를 가져오는 것과 같은 IO 작업을 모사하기 위해 delay() 함수를 사용함
- Thread.sleep() 함수와 마찬가지로 delay()도 현재 코루틴을 잠들게 함
- 그러나 Thread.sleep()과 다른 점이 있는데, 코루틴이 잠들어 있는 동안 다른 코루틴은 정상적으로 실행 될 수 있다는 것임
- 이건 delay() 함수에 suspend 키워드가 붙어 있기 때문임
- 이에 관해서는 다음 절에 자세히 설명함
- 이 코드를 실행하면 200밀리초 남짓 밖에 걸리지 않는 것을 볼 수 있음
- 스레드를 사용하면 20초가 걸리거나 메모리 초과 오류가 발생했을 것
- 코드도 별로 많이 고치지 않암ㅆ음
- 코루틴이 높은 동시성을 제공하는 덕
- 코루틴을 일시 중단하더라도 그 스레드는 멈추지 않는다.
- 스레드가 멈추지 않는다는 것은 엄청난 장점임
- 값비싼 OS스레드를 덜 쓰고도 더 많은 일을 할 수 있기 때문임

#### 코루틴 사용시 주의사항
- 해당 코드를 Intellij에서 사용시 GlobalScope가 주의해야 하는 API로 표시되는것을 볼 수 있음
- GlobalScope의 내부 동작을 잘 이해하지 못한다면 실제 프로젝트에서는 사용하면 안된다는 뜻
- 함부로 사용하면 원하지 않는 자원 누출이 발생할 수 있음
- 6장 뒷부분에서 코루틴을 시작하는 더 좋은 방법을 배운다
- 코루틴이 스레드보다 더 높은 동시성을 제공하기는 하지만 그렇다고 마법이 숨어있는 것은 아님
- 이제 코루틴을 시작하는 다른 방법을 알아보고 코루틴을 사용하더라도 여전히 발생하는 문제에 어떤 것이 있는지 본다

#### 코루틴 사용시 발생하는 문제
- launch()함수는 아무것도 반환하지 않는 코루틴을 시작함. 반면에 async() 함수는 어떤 값을 반환하는 코루틴을 시작함
- launch() 함수 호출은 반환형이 Unit인 함수를 호출하는 것과 같음
- 그러나 대부분의 함수는 어떤 결과를 반환함
- 그래서 async() 함수가 존재함
- 코루틴을 띄우는 것은 똑같지만, 작업 대신 Deffered<T>를 반환함
- 이때 T는 나중에 얻게 될 반환값의 타입을 나타냄
- 예를들어 다음 함수는 UUID를 비동기적으로 생성해 반환하는 코루틴을 시작
```
fun fastUuidAsync() = GlobalScope.async {
    UUID.randomUUID()
}
println(fastUuidAsync())
```
- main 메서드에서 다음 함수를 실행하면 예상한 결과가 출력되지 않음
- 즉 UUID가 아니라 다음과 같은 문구가 출력됨
```
> DeferredCoroutine{Active}
```
- 코루틴이 반환한 객체를 작업이라고 부름. 이것이 무엇이며 어떻게 사용해야 하는지 자세히 알아본다

### 작업
- 비동기적으로 어떤 일을 시작헀을 때 그 결과를 작업이라고 부름
- 마치 Thread 객체가 실제 OS스레드를 표현하는 것과 같이 Job객체는 실제 코루틴을 나타냄
- 이 예제 코드의 결과는 Job 이었던 것임
```
val job: Job = fastUuidAsync()
println(job)
```
- 작업의 생애 주기는 단순함
- 다음의 네가지 상태를 가질 수 있음
  - 신규 : 생성됐으나 시작되지 않음
  - 활성 : launch() 함수 등에 의해 시작됨, 기본 상태
  - 완료 : 모든 것이 순조롭게 진행됨
  - 취소 : 무언가 잘못됨
- 자식이 있는 작업은 다음과 같이 두가지 상태를 추가로 갖음
  - 완료 중 : 완료하기 전에 자식이 실행되기를 기다리는 중
  - 취소 중 : 취소하기 전 자식이 실행되기를 기다리는 중
- 작업의 부모 자식 관계에 대해 자세히 알고 싶다면 6장의 구조화된 동시성 절을 읽음 됨
- 앞의 예제에서 출력된 작업은 활성 상태에 있었음
- 즉 아직 UUID 생성을 마치지 못한 상태임
- 값을 갖는 작업을 Deferred라고 함
```
val job : Deferred<UUID> = fastUuidAsync()
```
- Deferred에 대해서는 8장에서 더 자세히 다룰 것
- 작업이 완료되기를 기다려서 실제 반환값을 가져오려면 await() 함수를 사용함
```
val job: Deferred<UUID> = fastUuidAsync()
println(job.await())
```
- 그러나 이 코드는 다음과 같은 오류 메시지를 내며 컴파일 되지 않는다.
```
> Suspend function 'await' should be called only from a coroutine or another suspend function
```
- 메시지에서 알 수 있듯 main() 함수가 suspend 함수도 코루틴도 아니기 때문에 오류가 발생함
- 다음과 같이 runBlocking 함수로 코드를 감싸면 문제가 해결됨
```
runBlocking{
    val job: Deferred<UUID> = fastUuidAsync()
    println(job.await())
}
```
- runBlocking함수는 모든 코루틴이 끝날 때 까지 메인 스레드를 중지시킴
- 이 함수는 4장에서 배운 브리지 패턴을 구현하고 있는데, 일반 코드와 코루틴을 사용하는 코드 사이에 다리를 좋아줌
- 이 코드를 실행하면 드디어 기대했던 대로 임의의 UUID가 출력됨