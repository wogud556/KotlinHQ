## 스레드 심화
- 스레드의 복잡한 부분을 본격적으로 살펴보기 앞서 먼저 스레드가 어떤 문제들을 해결하는 데에 사용되는지 알아본다.
- 요즘 노트북 컴퓨터는 멀티코어 CPU가 장착돼 있다.
- 코어 수는 4개 쯤 될 것
- 15년전만해도 단일 코어 CPU가 기본이었고 겨우 2코어짜리 CPU도 오로지 컴퓨터 광들만 사용했다는 것을 생각하면 놀라운 일
- 하지만 그때도 동시에 하나의 작업만 수행할 수 있었던것은 아님
  - 인터넷 검색을 하면서 동시에 음악을 들을 수 있음
  - 단일 코어 CPU에서도 말임
  - 이것이 어떻게 가능했을까? 그것은 뇌가 일하는 방식과 같음
  - 작업으로 저글링을 하는 것이다.
  - 친구가 말하는 것을 들으면서 책을 읽고 있다면, 책을 읽지 못할 때도 있고 친구의 말이 들리지 않을 때도 있음
  - 뇌는 코어가 하나 뿐이라 그렇다.
- 서버용 CPU도 노트북 CPU와 크게 다르지 않음
  - 서버라고 해도 동시에 기껏해야 4개의 요청을 처리할 수 있다는 말임
  - 하지만 초당 1만개의 요청이 들어온다면 어떻게하나?
  - CPU코어가 1만개가 아닌 이상 병렬로 처리할 수는 없음
  - 그러나 동시에 처리해 볼 수는 있음
- JVM이 제공하는 가장 기본적인 동시성 모델은 스레드임
- 스레드를 사용하면 두 코드를 동시에 실행해서 여러개의 CPU코어를 더욱 잘 활용할 수 있게 됨
- 스레드는 프로세스보다 더 가벼움, 하나의 프로세스 내에 수백개의 스레드가 만들어질 수 있음
- 프로세스와 달리 스레드간 손쉽게 자료를 공유할 수 있다. 하지만 이것이 꼭 좋은 것만은 아님
- 스레드간 자료 공유 때문에 발생하는 문제는 나중에 살펴볼 것
- 먼저 자바에서 스레드를 2개 생성하는 방법을 배운다.
- 각 스레드는 0부터 100까지의 수를 출력함
```
스레드 기본 선언
for(int t = 0; t<2; t++) {
    int finalT = t;
    new Thread(() -> {
        for(int i = 0; i<100; i++){
            System.out.println("Thread " + finalT + ": " + i);
        }
    }).start();
}
```
- 출력 결과는 아래와 같다
```
> ...
> T0: 12
.
.
.
> T1: 16
```
- 출력은 실행할 때마다 달라지며 언제 스레드 전환이 일어날지도 알 수 없다는 점에서 유의해야 한다
- 위의 코드를 코틀린으로 작성하면 아래와 같음
```
repeat(2) {
    t-> thread {
        for(i in 1..100) {
            println("T$t: $i")
        }
    }
}
```
- 코틀린에서는 스레드 생성을 도와주는 함수 덕분에 보일러 플레이트 코드를 덜 작성할 수 있음
- 자바에서처럼 스레드를 시작하기 위해 start() 함수를 호출하지 않아도 됨
- 스레드는 기본적으로 생성 즉시 실행됨
- 만약 나중에 실행하고자 한다면 start 매개변수를 false로 설정함
```
val t = thread(start = false)
...
// 나중에
t.start()
```
- 자바의 데몬 스레드도 유용한 개념임
- 데몬 스레드는 실행 중에도 JVM이 종료 될 수 있기 때문에 중요하지 않는 배경 작업을 수행할 때 매우 유용함
- 자바의 스레드 API는 유창핮 API가 아니기 때문에 먼저 스레드를 변수에 할다앟ㄴ 뒤 데몬 스레드로 설정해줘야 함
- 코틀린에서는 훨씬 간단하게 할 수 있음
```
thread(isDaemon = true) {
    for(i in 1..1_000_000) {
        println("데몬 스레드: $i")
    }
}
```
- 이 스레드는 100만까지 출력하도록 헀지만 실제로는 몇 백 정도에서 출력을 멈출 것
- 데몬 스레드이기 때문
- 부모 스레드가 멈추면 모든 데몬 스레드도 함꼐 종료됨

### 스레드 안정성
- 오로지 스레드 안정성만 다루는 책도 있음
  - 그럴 법도 하다
  - 스레드 안정성이 지켜지지 않아서 발생하는 동시성 버그는 잡아내기 가장 어려운 축에 속하기 떄문임
  - 게다가 재현도 쉽지 않음
  - 하나의 자원을 두고 여러 스레드가 경쟁하는 상황을 만들어야 실제 경합 조건이 발생함
  - 이 책은 스레드 안전성이 아니라 코틀린에 관한 책이므로 대충할거다
  - jvm언어에서의 스레드 안정성에 관심이 있다면 브라이언 게츠의 자바 병렬 프로그램을 참조한다
- 다음의 예제를 본다
- 이 코드에서는 counter 변수를 증가시키는 스레드를 10만개 만듬
- 최종적으로 counter 변수의 값을 확인하기 전에 먼저 모든 스레드가 작업을 끝냈다는 것을 확인하기 위해 CountDownLatch를 사용할 것
```
val counter = 0
val
```