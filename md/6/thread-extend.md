## 스레드 심화
- 스레드의 복잡한 부분을 본격적으로 살펴보기 앞서 먼저 스레드가 어떤 문제들을 해결하는 데에 사용되는지 알아본다.
- 요즘 노트북 컴퓨터는 멀티코어 CPU가 장착돼 있다.
- 코어 수는 4개 쯤 될 것
- 15년전만해도 단일 코어 CPU가 기본이었고 겨우 2코어짜리 CPU도 오로지 컴퓨터 광들만 사용했다는 것을 생각하면 놀라운 일
- 하지만 그때도 동시에 하나의 작업만 수행할 수 있었던것은 아님
  - 인터넷 검색을 하면서 동시에 음악을 들을 수 있음
  - 단일 코어 CPU에서도 말임
  - 이것이 어떻게 가능했을까? 그것은 뇌가 일하는 방식과 같음
  - 작업으로 저글링을 하는 것이다.
  - 친구가 말하는 것을 들으면서 책을 읽고 있다면, 책을 읽지 못할 때도 있고 친구의 말이 들리지 않을 때도 있음
  - 뇌는 코어가 하나 뿐이라 그렇다.
- 서버용 CPU도 노트북 CPU와 크게 다르지 않음
  - 서버라고 해도 동시에 기껏해야 4개의 요청을 처리할 수 있다는 말임
  - 하지만 초당 1만개의 요청이 들어온다면 어떻게하나?
  - CPU코어가 1만개가 아닌 이상 병렬로 처리할 수는 없음
  - 그러나 동시에 처리해 볼 수는 있음
- JVM이 제공하는 가장 기본적인 동시성 모델은 스레드임
- 스레드를 사용하면 두 코드를 동시에 실행해서 여러개의 CPU코어를 더욱 잘 활용할 수 있게 됨
- 스레드는 프로세스보다 더 가벼움, 하나의 프로세스 내에 수백개의 스레드가 만들어질 수 있음
- 프로세스와 달리 스레드간 손쉽게 자료를 공유할 수 있다. 하지만 이것이 꼭 좋은 것만은 아님
- 스레드간 자료 공유 때문에 발생하는 문제는 나중에 살펴볼 것
- 먼저 자바에서 스레드를 2개 생성하는 방법을 배운다.
- 각 스레드는 0부터 100까지의 수를 출력함
```
스레드 기본 선언
for(int t = 0; t<2; t++) {
    int finalT = t;
    new Thread(() -> {
        for(int i = 0; i<100; i++){
            System.out.println("Thread " + finalT + ": " + i);
        }
    }).start();
}
```
- 출력 결과는 아래와 같다
```
> ...
> T0: 12
.
.
.
> T1: 16
```
- 출력은 실행할 때마다 달라지며 언제 스레드 전환이 일어날지도 알 수 없다는 점에서 유의해야 한다
- 위의 코드를 코틀린으로 작성하면 아래와 같음
```
repeat(2) {
    t-> thread {
        for(i in 1..100) {
            println("T$t: $i")
        }
    }
}
```
- 코틀린에서는 스레드 생성을 도와주는 함수 덕분에 보일러 플레이트 코드를 덜 작성할 수 있음
- 자바에서처럼 스레드를 시작하기 위해 start() 함수를 호출하지 않아도 됨
- 스레드는 기본적으로 생성 즉시 실행됨
- 만약 나중에 실행하고자 한다면 start 매개변수를 false로 설정함
```
val t = thread(start = false)
...
// 나중에
t.start()
```
- 자바의 데몬 스레드도 유용한 개념임
- 데몬 스레드는 실행 중에도 JVM이 종료 될 수 있기 때문에 중요하지 않는 배경 작업을 수행할 때 매우 유용함
- 자바의 스레드 API는 유창핮 API가 아니기 때문에 먼저 스레드를 변수에 할다앟ㄴ 뒤 데몬 스레드로 설정해줘야 함
- 코틀린에서는 훨씬 간단하게 할 수 있음
```
thread(isDaemon = true) {
    for(i in 1..1_000_000) {
        println("데몬 스레드: $i")
    }
}
```
- 이 스레드는 100만까지 출력하도록 헀지만 실제로는 몇 백 정도에서 출력을 멈출 것
- 데몬 스레드이기 때문
- 부모 스레드가 멈추면 모든 데몬 스레드도 함꼐 종료됨

### 스레드 안정성
- 오로지 스레드 안정성만 다루는 책도 있음
  - 그럴 법도 하다
  - 스레드 안정성이 지켜지지 않아서 발생하는 동시성 버그는 잡아내기 가장 어려운 축에 속하기 떄문임
  - 게다가 재현도 쉽지 않음
  - 하나의 자원을 두고 여러 스레드가 경쟁하는 상황을 만들어야 실제 경합 조건이 발생함
  - 이 책은 스레드 안전성이 아니라 코틀린에 관한 책이므로 대충할거다
  - jvm언어에서의 스레드 안정성에 관심이 있다면 브라이언 게츠의 자바 병렬 프로그램을 참조한다
- 다음의 예제를 본다
- 이 코드에서는 counter 변수를 증가시키는 스레드를 10만개 만듬
- 최종적으로 counter 변수의 값을 확인하기 전에 먼저 모든 스레드가 작업을 끝냈다는 것을 확인하기 위해 CountDownLatch를 사용할 것
```
val counter = 0
val latch = CountDownLatch(100_000)
repeat(100) {
    thread{
        repeat(1000) {
            counter ++
            latch.countDown()
        }
    }
}
latch.await()
println("Counter $counter")
```
- 이 코드가 올바른 값을 출력하지 않는 것은 ++연산자가 원자적이지 않은 까닭에 경합 조건이 발생했기 때문
- 더 많은 스레드가 counter 변수의 값을 증가시키려 함수와 경합이 발생할 확률은 올라감
- 자바와 달리 코틀린에는 synchronized 키워드가 없음
- 코틀린을 설계한 사람들은 어떤 특정한 동시성 모델에만 맞춰 언어를 만들면 안된다고 생각했기 때문
- 대신 synchronized() 함수를 사용할 수 있음
```
thread {
    repeat(1000) {
        synchronized(latch) {
            counter ++
            latch.countDown()
        }
    }
}
```
- 이제 이코드는 예상대로 100,000을 출력함
- 자바의 synchronized 키워드가 그립다면 코틀린에서는 @Synchronized 어노테이션을 사용할 수 있다.
- 자바의 volatile 키워드도 @volatile 어노테이션으로 대체함
- 표 6.1은 예제와 함께 양쪽을 비교함
- 표 그리기 귀찮은디

|자바|코틀린|
|--|--|
|synchronized void doSomething()|@Synchronized fun doSomething()|
|volatile int sharedCounter = 0;|@Volatile  var sharedCounter| Int = 0|

- Synchronized와 Volatile이 키워드가 아닌 어노테이션인 이유는 코틀린이 jvm이외의 다른 플랫폼으로도 컴파일 될 수 있기 때문
- 반면 Synchronized 메서드의 volatile 변수는 JVM에서만 존재함

### 왜 스레드는 값비싼가?
- 스레드 생성에는 비용이 따름
- 각 스레드는 새로운 메모리 스택이 필요하다.
- 스레드에서 Sleep을 호출해 어떤 작업을 모사하면 어떻게 될까?
- 다음 코드에서는 1만개의 스레드를 생성함. 각 스레드는 비교적 짧은 시간 동안 잠들며 걸리는 어떤 작업을 모사함
```
val counter = AtomicInteger()
try{
    for (i in 0..10_000) {
        thread {
            counter.incrementAndGet()
            Thread.sleep(100)
        }
    }
} catch (oome: OutOfMemoryError) {
    println("오류가 발생하기 전까지 ${counter.get()}개의 스레드를 생성")
    System.exit(-42)
}
```
- 각 스레드는 스택을 만드릭 위해 1MB의 램 공간이 필요함
- 따라서 스레드를 너무 많이 만들면 운영체제에서 너무 자주 접근하게 될 뿐만 아니라 메모리도 많이 소요됨
- 코드에서는 메모리가 부족한 상황이 실제로 발생하는지 확인하기 위해 이에 해당하는 예외를 잡음
- 사용하는 운영체제에 따라 OutOfMemoryError가 발생할 수 있고, 아니면 전체 시스템이 굉장히 느려질 수 있음
- 당연히 Excutors API를 사용하면 한 번에 실행 가능한 스레드의 개수를 제한할 수 있음
- 이 API를 사용하면 정해진 크기의 스레드 풀을 생성할 수 있음. 풀의 크기를 1로도 설정해보고, 컴퓨터의 코어 개수와 동일하게도 설정해보고, 100이나 2000으로도 설정해보면서 어떤일이 일어나는지 본다
```
val pool Executors.newFixedThreadPood(100)
```
- 이제 pool.submit() 함수를 호출하면 새로운 작업 스레드 풀에 요청할 수 있음
```
val counter = AtomicInteger(0)
val start = System.currentTimeMillis()
for(i in 1..10_000){
    pool.submit {
        // 어떤 작업
        counter.incrementAndGet()

        // IO 작업 대기를 모사
        Thread.sleep(100)

        // 또 다른 작업을 수행
        counter.incrementAndGet()
    }
}
```
- sleep을 호출하기 전과 후에 counter를 증가시킴으로 비즈니스 로직을 모사함
- 예를 들어 sleep 호출 전의 작업은 Json 데이터를 준비하는 로직을, sleep 호출은 네트워크 작업을, sleep 호출 후의 작업은 결과를 파싱하는 로직을 모사한다고 생각할 수 있음.
- 그리고 다음 코드를 사용하여 최대 20초 후에는 스레드풀이 반드시 종료되도록 할 수 있음
```
pool.awaitTermination(20, TimeUnit.SECONDS)
pool.shutdown()
println("${System.currentTimeMillis() - start} 밀리초 동안 ${counter.get() / 2} 개의 작업을 완료함")
```
- 이 코드는 20초가 지나서 종료됨
- 이전 작업이 잠에서 깨어나서 작업을 완료할 때 까지는 새로운 스레드가 작업을 시작할 수 없기 때문
- 이게 바로 멀티스레드 시스템에서 일어나는 일임
- 동시성이 충분하지 않기 때문에 자원을 최대한으로 사용하지 못함
- 다음 절에는 코루틴을 사용하여 이러한 문제를 해결하는 법을 본다.
- 