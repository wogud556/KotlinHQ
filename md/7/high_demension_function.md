## 집합 자료 구조를 위한 고차 함수
- 이 주제는 1장에서 짫게 다룸
- 하지만 스트림을 살펴보기 전에, 집합 자료 구조를 위한 고차 함수가 존재하지 않는 언어를 사용하던 독자들도 이것이 무엇이며, 어떤이점을 갖다 주는지 이해할 수 있도록 조금 더 자세히 설명함
- 집합 자료 구조에 적용할 수 있는 모든 함수를 다루지는 못할 것
- 가장 자주 사용되는 몇가지 설명할 것

### 원소 매핑
- map()함수는 자료 구조의 각 원소를 받아서 새로운 원소를 반환함
- 새로운 원소는 입력 원소와 다른 타입일 수 있음
- 이해를 돕기 위해 문자 리스트가 있을 때 각 문자에 대응하는 ASCII 값을 출력하는 코드를 작성해본다
- 먼저 절차지향적으로 작성한 코드는 다음과 같음

```
val letters = 'a'..'z'
val ascii = mutableListOf<Int>()
for ( l in letters) {
    ascii.add(l.toInt())
}
```
- 간단한 작업임에도 꽤 많은 코드를 작성해야 하는 것을 볼 수 있음
- 출력 리스트를 가변형으로 만들어야 하는 것도 문제임
- 이번에 map()함수를 사용해서 같은 일을 하는 코드를 작성해본다
```
val result : List<Int> = ('a'..'z').map(it.toInt())
```
- 보다시피 훨씬 짧게 구현할 수 있음
- 가변 리스트를 선언할 필요도 없고 직접 for-in 반복문을 작성할 필요도 없음

### 원소 필터링
- 집합 자료구조를 필터링하는 것도 자주 하는 작업
- 절차지향적인 방법은 뻔함. 자료구조를 반복을 수행하면서 어떤 기준을 만족하는 원소를 새 자료구조에 넣는 것
- 예를 들어  1 부터 100까지의 범위의 수가 있을 때 3이나 5의 배수만큼 얻어낸다고 한다.
- 절차 지향적으로 작성한 함수는 다음과 같이 생겼을 것

```
val numbers = 1..100
val notFizzbuzz = mutableListOf<Int>()
for(n in numbers) {
    if(n % 3 == 0 || n % 5 == 0 ) {
        notFizzbuzz.add(n)
    }
}
```
- 함수형 버전에서는 filter() 함수를 사용함

```
val filtered: List<Int> = (1..100).filter {it % 3 == 0 || it % 5 == 0 } 
```
- 이번에도 코드가 훨씬 간결해진 것을 볼 수 있음
- 함수형 코드에서는 '무엇이' 필요한지만 표현, 즉 기준에 맞는 원소를 뽑아내라는 것만 코드에 표현하고 이를 '어떻게' 할 지(가령 if 표현식을 이용하는 것)는 감춤

### 원소 검색
- 자료 구조에서 어떤 조건을 만족하는 첫 번째 원소를 찾는 것도 매우 일반적인 작업
- 3과 5의 공약수를 찾는 함수는 다음과 같이 작성할 수 있을 것
```
for findFizzbuzz(numbers: List<Int>) : Int {
    for (n in numbers) {
        if(n % 3 && n % 5 == 0) {
            return n
        }
    }
    return null
}
```
- find 함수를 사용하면 같은 일을 하는 함수를 다음과 같이 작성할 수 있음
```
val found(numbers: List<Int>): Int? = numbers.find{ it % 3 == 0 && it % 5 == 0}
```
- 절차 지향적 스타일로 작서앟ㄴ 함수에서와 마찬라지로 find함수는 조건을 만족하는 원소가 없을 때 null을 반환함
- 짝을 이루는 findLast()함수도 있는데, 이 함수는 find()와 같이 조건을 만족하는 원소를 찾지만 자료 구조의 끝에서부터 검색을 시작한다는 점이 다름

### 각 원소에 대해 코드 실행
- 앞서 소개한 모든 함수는 모두 한가지 특징이 있음
- 함수의 결과가 스트리밍이라는 것임
- 하지만 모든 고차 함수가 스트림을 반환하는 것은 아님
- 어떤 함수는 Unit이나 숫자와 같은 값 하나만 반환할 수 있음
- 이런 함수를 종결함수라고 함
- 이번에는 종결함수를 하나 소개할 것
  - 종결 함수는 새로운 자료 주고를 반환하지 않고 다른 것을 반환함
  - 따라서 종결 함수에는 다른 함수에 이어서 연쇄 호출을 할 수 없음
  - 이렇게 함수의 연쇄 호출이 종결되기 때문에 종결함수라고 부르는 것
- forEach()함수는 Unit 타입을 반환함
  - Unit 타입이란 자바의 void와 비슷하며 쓸모있는 값을 반환하지 않음을 의미함
  - 그래서 forEach()함수는 보통의 for반복문과 흡사함

```
val numbers = (0..5)
numbers.map {it * it}
       .filter{it < 20 }
       .forEach(println(it))
```
- forEach()함수는 전통적인 for 반복문에 비해 성능 면에서는 약간 뒤쳐질 수 있다는 점을 유념한다
- forEachIndexed()라는 함수도 있음
- 이 함수를 사용하면 집합 자료구조의 원소 값과 함께 인덱스 값도 얻을 수 있음
- 이 함수를 사용하면 집합 자료구조의 원소 갑소가 함께 인덱스 값도 얻을 수 있음

```
numbers.map{ it * it }
       .forEachIndexed{ intex, value -> print("$index:$value,")
       
}
```
- 이 코드의 출력은 다음과 같음
>> 0:1, 1:4, 2:9, 3:16, 4:25,

- 코틀린은 1.1버전부터 onEach()라는 함수도 제공함.
- 이 함수는 입력 자료구조를 그대로 다시 반환하기 때문에 더 유용하게 쓸 수 있음

```
numbers.map {it * it}
       .filter{it < 20 }
       .sortedDescending()
       .onEach { println(it)}
       .filter{it > 5 }
```
- 볻시피 이 함수는 종결 함수가 아님

### 원소의 총합
- forEach() 함수처럼 reduce() 함수도 종결함수임
- 하지만 쓸모 없는 Unit으로 끝나지 않고 자료구조의 원소 자료형과 동일한 타입의 값을 하나 반환함
- reduce()를 실제로 사용하는 방법을 이해하기 위해서 1과 100 사이의 모든 수를 더하는 코드를 작성해본다.
```
val numbers = 1..100
var sum = 0
for(n in numbers) {
    sum += n
}
```
- 이번엔 reduce를 이용해 같은 기능을 하는 코드를 작성한다.

```
val reduced : Int = (1..100).reduce{ sum , n -> sum + n}
```
- 원소의 합을 저장하는 가변 변수를 선언하지 않아도 된다는 사실에 주목한다
- 앞서 본 고차 함수와는 달리 reduce() 함수는 2개의 입력을 취함
- 첫 번째 인수는 누적 변수로 절차 지향적 코드의 sum과 같음
- 두번쨰 인수는 다음 원소를 가리킴
- 예제 코드에서 같은 역할을 하는 변수는 같은 이름을 갖도록 했으니 두 코드를 비교해보면 쉽게 이해할 수 있을 것

### 중첩 제거
- 다른 자료 구조를 원소로 갖는 자료 구조를 만날 때가 있음
- 예를 들어 다음과 같은 코드를 본다
```
val listOfLists : List<List<Int>> = listOf(listOf(1,2), listOf(3,4,5))
listOf(6,7,8)
```
- 그런데 만약 이 자료구조를 중첩이 없는 하나의 리스트로 바꾸고 싶다면 어떻게 하나?
- 변환한 리스트를 출력해보면 다음과 같다.

> [1,2,3,4,5,6,7,8]

- 한가지 방법은 입력 리스트를 순회하며 가변 리스트의 addAll 함수를 사용하는 것
```
val flattened = mutableListOf<Int>
for(list in listOfLists) {
    flattened.addAll(list)
}
```
- 더 좋은 방법은 flatMap() 함수를 사용하는 것
```
val flattened : List<Int> = listOfLists.flatMap { it }
```
- 이 경우에는 flatten() 함수를 사용하면 더 간단하게도 만들 수 있음
```
val flattened : List<Int> = listOfLists.flatten()
```
- 하지만 일반적으로 flatMap() 함수가 더 쓸모가 많음.
- 각 원소 자료 구조에 다른 함수를 적용할 수 있기 때문
- 집합 자료구조에 적용할 수 있는 고차 함수는 소개한 것보다 훨씬 더 많음
- 이 함수들을 짧은 지면에 다 담을 수는 없기에 공식 문서를 읽어보며 공부하기 바람
- 하지만 다음 절에서 다룰 주제를 이해하기 위해서는 지금까지 소개한 함수만 잘 알아도 충분할 것
- 이제 정적 자료 스트림을 변환하고 순회하는 방법을 익혔으니 동적 자료 스트림에 대해 서는 똑같은 작업을 어떻게 할 수 있는지를 알아본다.