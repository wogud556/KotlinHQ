## 동시성 자료구조 소개
- 자료 구조와 함께 사용할 수 있는 고차 함수 중 가장 많이 사용되는 몇가지를 알아봤으니, 이를 6장에서 배운 코틀린 동시성 문법과 결합해서 동시성 자료 구조를 다루는 방법을 살펴본다
- 가장 중요한 동시성 자료 구조는 채널과 흐름
- 하지만 이 두가지를 다루기 전에 우선 순서열이라는 자료구조를 먼저 살펴봐야 함
- 순서얄 자체는 동시성 자료 구조가 아니지만 동시성의 세계로 들어가는 다리를 놓아줄 것

### 순서열
- 집합 자료 구조를 위한 고차함수는 오래 전부터 많은 함수형 프로그램밍 언어에 존재했음
- 하지만 자바 개발자들은 자바 8 버전에서야 스트림 API의 등장과 함께 처음으로 집합 자료 구조용 고차 함수를 사용할 수 있게 됨
- 스트림 API는 map()과 filter()를 비롯해 앞서 소개한 유용한 함수를 제공했지만 두 가지 중대한 문제가 있음
- 첫 번째는 이 함수들을 사용하기 위해서 자바 8로 버전을 변경해야 한다는 것
- 스트림에 모든 API함수가 정의돼 있기 때문
- 스트림에서 매핑과 필터링 등의 작업을 한 뒤 집합 자료구조를 반환하려면 다시 collect 함수를 호출해야 했음
- 스트림과 집합 자료 구조 사이에는 중요한 차이가 하나 더 있음
- 집합 자료구조와는 달리 스트림은 무한히 길 수 있다는 점
- 코틀린은 JVM에 한정되지 않으며 자바 6까지의 하위 호환성을 보장하기 때문에 무한한 스트림을 지원하기 위한 다른 방법이 필요했음
- 이렇게 탄생한 자료 구조는 자바의 스트림과 이름 충돌을 피하기 위해 순서열이라는 이름을 얻음
- 새 순서열은 generateSequence()함수를 사용해서 만듬
- 예를 들어 다음 함수는 무한한 순서열을 생성함
```
val seq: Sequence<Long> = generateSequence(1L) { it + 1 }
```
- 첫번째 인수로는 순서열의 초깃값을, 두번째 인수로는 이전 값을 이용해 다음 값을 만들어 내는 람다 함수를 전달
- generateSequence함수의 반환형은 Sequence임
- 일반적인 자료구조나 범위도 asSequence() 함수를 이용해 순서열로 변환할 수 있음
```
(1..100).asSequence()
```
- 더 복잡한 로직을 이용해 순서열을 만들어야 한다면 다음과 같이 sequence()함수를 사용할 수 있음

```
val fibSeq = sequence {
    var a = 0
    var b = 1
    yield(a)
    yield(b)

    while(true) {
        yield(a + b)
        val t = a
        a = b
        b += t
    }
}
```
- 이 예제는 피보나치 수의 순서열을 만드는데 yield함수를 이용해 다음 값을 반환함
- 순서열의 값을 사용할 때 마다 마지막으로 yield()가 호출된 지점부터 코드의 실행이 재개될 것
- 순서열이라는 개념 자체는 그다지 유용해 보이지 않을 수 있지만 순서열과 집합 자료구조의 차이를 이해하는 것은 굉장히 중요함
- 순서열은 게으르며 집합자료구조는 부지런함
- 따라서 집합 자료 구조의 크기가 일정 수준을 넘어서면 고차 함수를 적용했을 때 보이지 않는 비용이 발생함
- 대부분의 고차 함수는 불변성을 유지하기 위해 자료 구조를 복사해서 사용할 것이기 때문
- 이 차이를 이해하기 위해서 다음 코드를 살펴본다
- 먼저 백만 개의 수가 들어 있는 리스트를 만들고, 각 수를 제곱하는 데에 어느 정도 시간이 걸리는지 측정해본다
- 집합 자료구조를 이용해 측정한 뒤에 순서열을 이용해서 측정해볼 것

```
val numbers = (1..1_000_000).toList()
println(measureTimeMillis {
    numbers.map{
        it * it
    }.take(1).forEach{it}
}) 

println(measureTimeMillis {
    numbers.asSequence().map{
        it * it
    }.take(1).forEach{ it }
})
```
- 여기서는 집합 자료 구조에 적용할 수 있는 또 다른 고차 함수인 take()를 사용함
- 이 함수를 통해 첫번째 원소만 취해서 계산을 수행하도록 함
- 실행 결과를 보면 순서열을 이용한 코드가 훨씬 빠른 것을 알 수 잇음
- 이것은 순서열이 각 원소에 적용하는 연산을 게으르게 실행하기 때문
- 즉 전체 리스트에서 원소 하나에 대해서만 제곱을 계산함
- 반면 집합 자료 구조에 적용한 함수는 전체 리스트에 대해 연산을 수행함
- 즉 모든 수의 제곱을 먼저 계산해서 새 자료 구조에 넣은다음, 그 결과에서 첫 번째 수만 취한 것
- 순서열과 채널,흐름은 반응형 프로그래미으이 원칙을 따르기 때문에 이 원칙의 의밀르 잘 이해하고 넘어갈 필요가 있음
- 반응형 프로그래밍의 원칙은 꼭 함수형 프로그래밍에만 적용되는 것이 아님. 객체지향적인 코드나 절차지향적 코드를 작성하면서도 반응형 프로그래밍을 할 수 있음
- 하지만 역시 함수형 프로그래밍의 기초를 배우고 나면 반응형 프로그래밍을 더 쉽게 이해할 수 있음

### 채널
- 6장에서 코루틴을 띄우고 제어하는 방법을 배움
- 그런데 두 코루틴 간 통신을 하기 위해선 어떻게할까
- 자바에서는 wait()/notify()/notifyAll() 패턴을 사용하거나 java.util.concurrent 패키지에 잘 갖춰진 여러 클래스를 사용해서 스레드간 통신을 함
- 코틀린에는 wait()이나 notify() 메서드가 없음
- 대신 코루틴은 채널을 사용함
- 채널은 BlockingQueue 와 매우 비슷하지만 스레드가 아닌 코루틴을 멈춤
- 스레드를 멈추는 것보다 훨씬 적은 비용으로
- 다음의 단계를 통해 채널과 코루틴을 생성할 것
  - 1. 먼저 채널을 하나 만듬
  ```
  val chan = Channel<Int>
  ```
    - 채널은 타입을 갖음
    - 이 채널은 정수만 받을 수 있음
  - 2. 다음으로는 이 채널에서 값을 읽는 코루틴을 생성함
  ```
  launch {
    for (c in chan) {
        println(c)
    }
  }
  ```
    - 채널에서 값을 읽으려면 그냥 for-in 반복문을 사용하면 됨
  - 3. 이제 이 채널로 값을 전송해본다. send() 함수를 사용하면 됨
  ```
    (1..100).forEach {
        chan.send(it)
    }
    chan.close()
  ```
  - 4. 마지막으로 채널을 닫음 채널이 닫히면 이 채널에서 값을 읽던 코루틴은 for-in 반복문을 빠져나옴
      - 반복문 이후에 다른 할 일이 없기 대문에 코루틴은 종료됨
- 이런 통신 형태를 순차 프로세스 또는 줄여서 CSP 라고 부름
- 보다시피 채널을 사용하면 여러 코루틴 간에 편리하고 타입 안전하게 통신이 가능함
- 하지만 채널을 직접 정의해 줘야 함
- 이어지는 두 절에서는 더욱 간단하게 채널을 다루는 법을 알아볼 것

### 생산자 코루틴
- 채널에 값을 공급하는 코루틴이 필요하다면 produce()함수를 사용해 생산자 코루틴을 만들 수 있음
- 공급하고자 하는 값의 타입을 T라고 할 때 produce() 함수는 내부적으로 ReceiveChannel<T>을 갖고 있는 코루틴을 생성함
- 위의 예제를 produce()로 다시 작성하면 다음과 같음
```
val chan = produce {
    (1..10).forEach [
        send(it)
    ]
}
launch {
    for(c in chan) {
        println(c)
    }
}
```
- produce() 블록 내에서는 바로 send()함수를 사용해서 채널에 값을 공급할 수 있다는 것에 주목
- 채널의 값을 소비하는 코루틴에서는 for-in 반복문 대신 consumeEach() 함수도 쓸 수 있음

```
launch {
    chan.consumeEach {
        println(it)
    }
}
```
- 이번에는 채널에 결합된 또 다른 코루틴을 만드는 방법을 알아본다.

### 행위자 코루틴
- 행위자 코루틴을 만드는 actor() 함수는 produce()함수와 마찬가지로 내부에 채널을 갖고 있는 코루틴을 생성함
- 다만 생산자가 채널에 값을 제공하는 역할을 했다면 행위자는 채널에서 값을 가져오는 일을 함
- 다음의 예제 코드를 본다.

```
val actor = actor<Int> {
    channel.consumeEach {
        println(it)
    }
}
(1..10).forEach {
    actor.send(it)
}
```
- 이 예제에서는 메인 함수는 값을 생산하고 행위자는 채널을 통해 이를 소비함
- 처음 봤던 예제와 매우 비슷하지만 채널과 코루틴을 각각 만드는 대신 둘을 결합해 한 번에 만들었다는 점이 다름
- 스칼라를 비롯해서 행위자가 있는 프로그래밍 언어를 사용한 경험이 있다면 여기서 소개하는 행위자 모델과는 조금 다른 모델이 더 익속할 것
- 예를 들어 행위자가 입력 채널과 출력 채널(채널 대신 편지함이라는 용어를 쓰기도 함)을 모두 갖도록 구현하기도 함. 하지만 코틀린에서 행위자는 입력 편지함 하나만 갖음

### 버퍼가 있는 채널
- 채널을 명시적으로 또는 암시적으로 생성한 지금까지의 모든 예제는 버퍼가 없는 버전의 채널으 ㄹ사용함
- 버퍼가 무엇인지 이해하기 위해 앞의 예제를 조금 바꿔본다

```
val actor = actor<Long> {
    val prev = 0L
    channel.consumeEach {
        println(it - prev)
        prev -= it
        delay(100)
    }
}
```
- 여기서 actor 객체는 앞의 예제와 비슷함
- 타임 스탬프 값을 받아서 직전 타임 스탬프 값과의 차이를 반환함
- 그러고 나서 다음 값을 읽기 전에 약간의 시간 지연을 줌
- 메인 함수에서 이 actor 객체에 순서열이 아닌 현재 타임 스탬프를 전송해본다
```
repeat(10) {
    actor.send(System.currentTimeMillis())
}
actor.close().also { println("전송 완료") }
```
- 이제 이 코드의 출력을 살펴보면 다음과 같음
```
>...
>101
>103
>101
전송완료
```
- 채널이 다음 값을 받을 준비가 될 때까지 생산자가 멈춰 있는 것을 볼 수 있음
- 즉 actor객체가 자신이 준비될 때 까지 다음 값을 전송하지 말라는 의미의 배압을 생산자에게 가하는 것
- 이제 actor의 정의를 살짝 바꿔본다
```
val actor = actor<Long>(capacity = 10) {
    ...
}
```
- 모든 채널에는 용량이 있음
- 용량의 기본 값은 0임
- 즉 채널에 들어 있는 값이 소비되기 전 까지는 아무도 채널에 새로운 값을 전송할 수 없다는 것임
- 이 코드를 다시 실행해보면 완전히 다른 결과를 얻는다.

```
>전송완료
>...
>0
>0
```
- 생산자는 더이상 소비자를 기다리지 않음
- 채널에 버퍼가 생겼기 때문
- 따라서 생산자는 보낼 수 있는 최대한의 속도로 메시지를 전송하고, 행위자는 자신의 속도에 맞춰 이를 처리할 수 잇음
- capacity는 생산자 채널에서도 비슷한 방법으로 지정할 수 있음

```
val chan = produce (capacity = 10) {
    (1..10).forEach {
        send(it)
    }
}
```
- 뿐만 아니라 직접 채널을 선언할 때도 다음과 같이 용량을 지정할 수 있다

```
val chan = Channel<Int>(10)
```
- 버퍼가 있는 채널은 생산자와 소비자 간의 결합을 끊어 줄 수 있는 매우 강력한 도구
- 하지만 세심한 주의를 기울여 사용해야 함
- 채널의 용량이 크다면 그만큼 메모리 소비량도 많을 것
- 채널은 상대적으로 저수준의 동시성 도구
- 다음 절에는 다른 유형의 스트림을 살펴 볼텐데 이 유형은 채널보다 더 높은 수준의 추상화를 제공한다.

### 흐름
- 흐름은 차가운 비동기 스트림으로 4장에서 배운 관찰자 디자인 패턴을 구현하고 있음
- 잠시 기억을 되살려보면, 관찰자 디자인 패턴에는 2개의 메서드가 필요함
- 하나는 소비자가 메시지를 구독하는 subscribe() 함수이고, 다른 하나는 모든 구독자에게 메시지를 전송하는 publish() 함수이다.
- Flow객체에서 publish()에 해당하는 함수는 emit()이라고 부르고, subscribe()에 해당하는 함수는 collect()라고 부름
- 다음과 같이 flow() 함수를 사용하면 새 흐름을 만들 수 있음

```
val numbersFloe: Flow<Int> = flow {
    ...
}
```
- flow 생성자 내에서는 emit() 함수를 사용해 모든 수신자에게 새 값을 전송할 수 있다.
- 예를 들어 다음 코드는 flow 생성자를 이용해 10개의 수를 전송함
```
flow {
    (0..10).forEach {
        println("$it 전송 중")
        emit(it)
    }
}
```
- 메시지를 전송하는 법은 알았으니 이제 흐름을 구독하는 방법을 살펴본다
- 구독을 하려면 flow객체에 있는 collect() 함수를 사용
```
numbersFlow.collect {
    number -> println("$number 수신")
}
```
- 이 코드를 실행해보면 수신자가 흐름에서 수신한 모든 수를 출력하는 것을 볼 수 있음
- 여 타 반응형 프레임워크나 라이브러리와는 달리 수신자에게 예외를 던지는 별도의 문법은 존재하지 않음
- 그냥 다음과 같이 일반적인 throw 식을 사용하면 됨

```
flow {
    (1..10).forEach {
        ...
        if(it == 9) {
            throw RuntimeException()
        }
    }
}
```
- 수신 측에서 예외를 처리하려면 그냥 collect() 함수를 try/catch 블록으로 감싸면 됨

```
try {
    numberFlow.collect {
        number -> println("$number 수신")
    }
}
catch (e : Exception) {
    println("예외 처리 중")
}
``` 
- 흐름은 채널과 마찬가지로 코루틴을 일시 중단시킴
- 하지만 흐름은 동시성 자료 구조가 아님. 또한 흐름은 배압을 지원하지만 사용자가 완전히 통제할 수 있음
- 이것이 무슨 뜻인지 이해하기 위해서 여러 구독자가 하나의 흐름에서 값을 읽는 다음 예제를 살펴본다.

```
(1..4).forEach {
    coroutineId -> delay(5000)
    launch(Dispatchers.Default) {
        numbersFlow.collecgt {
            number-> delay(1000)
            println("${coroutineId}번 코루틴에서 $number 수신")
        }
    }
}
```
- 5초의 간격을 갖고 구독자마다 하나의 코루틴을 시작함
- 이를 통해 여러 구독자가 동시에 실행되는 것을 볼 수 있음
- 아래는 코드의 실행 결과
```
>...
>1 전송 중
>1번 코루틴에서 5 실시
>6 전송 중
>2번 코루틴에서 1 수신
>2 전송중
>1번 코루틴에서 6 수신
>...
```
- 이 결과를 통해 두 가지 중요한 사실을 알 수 있음

- 흐름은 차가운 스트림이다
  - 구독자마다 처음부터 새로 시작한다는 뜻
  - 앞의 예제에서 각 구독자는 1부터 시작해서 모든 수를 받을 수 있었음
- 흐름은 배압을 사용함
  - 즉 이전에 전송된 값을 수신 측에서 처리하기 전까지는 다음 수를 전송하지 않음
  - 버퍼 없는 채널과 비슷하며 버퍼 있는 채널과는 다름
  - 버퍼가 있는 채널에서는 생산자가 소비자의 소비 속도보다 더 빠르게 값을 전송할 수 있었음
- 이제 필요에 따라 두가지 속성을 바꾸는 방법을 알아본다


### 버퍼 있는 흐름
- 생산자에게 바로 배압을 가하고 싶지 않을 때도 있음. 가령 메모리가 충분하다면 처음부터 배압을 가할 필요가 없다
- 이를 위해서 각 소비자는 buffer()함수를 사용해 흐름에 버퍼를 만들 수 있음
```
numbersFlow.buffer().collect {
    number -> delay(1000)
    println("${coroutineId}번 코루틴에서 $number 수신")
}
```
